

<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java开发复习资料 | 帅羊羊的博客</title>
  
  <meta name="author" content="Shuai yy">
  
  <meta name="description" content="前言在被虐中成长，在面试中进步指缝很宽，时间太瘦，悄悄从指缝间溜走。转眼之间三年的研究生生活即将结束，即使很是不舍，也终将要走向社会，开始另一段新的旅程。此刻，看着下一届师弟师妹开始忙碌地准备找实习，便开始追忆起过去一年找实习和工作的历程，那是一段艰辛而又成长颇多的经历。
过去一年找实习和工作的经历">
  
  <meta name="keywords" content="Java开发基础">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java开发复习资料"/>
  <meta property="og:site_name" content="帅羊羊的博客"/>

  
    <meta property="og:image" content=""/>
  
  <link href="/favicon.ico" rel="icon" type="image/x-ico">
  <link rel="alternate" href="http://shuaiyy.cn/atom.xml" title="帅羊羊的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//libs.baidu.com/jquery/1.8.0/jquery.min.js"></script>
  
  
  
    


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script>
	var _hmt = _hmt || [];
	(function() {
		var hm = document.createElement("script");
		hm.src = "https://hm.baidu.com/hm.js?02f792017724a2c2af494ece7edc5fd1";
		var s = document.getElementsByTagName("script")[0]; 
		s.parentNode.insertBefore(hm, s);
	})();
</script>





  
    
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-107525911-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  
</head>



<body>
  <header id="header" class="inner">
<div class= "header-nav">

			<div class='avatar'>
				<img src = "http://img.shuaiyy.cn/blog/171005/FFHDJd20A4.jpeg?imageslim">
              </div>
		
<div class="header-div">
  
  <h1><a href="/">帅羊羊的博客</a></h1>
  <h2><a href="/">坚持学习,努力学习...</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
	  
    
      <li><a href="/archives"><i class="fa fa-archive"></i>归档</a></li>
	  
    
      <li><a href="/resume"><i class="fa fa-user"></i>关于</a></li>
	  
    
      <li><a href="/books"><i class="fa fa-book"></i>阅读</a></li>
	  
    
      <li><a href="/movies"><i class="fa fa-play-circle"></i>电影</a></li>
	  
    
      <li><a href="/games"><i class="fa fa-fa-gamepad"></i>游戏</a></li>
	  
    
	<li> <a href="/atom.xml"><i class="fa fa-rss"></i>RSS</a> </li>
<li> <a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() {
	function c() {
		var e = document.createElement("link");
		e.setAttribute("type", "text/css");
		e.setAttribute("rel", "stylesheet");
		e.setAttribute("href", f);
		e.setAttribute("class", l);
		document.body.appendChild(e)
	}
 
	function h() {
		var e = document.getElementsByClassName(l);
		for (var t = 0; t < e.length; t++) {
			document.body.removeChild(e[t])
		}
	}
 
	function p() {
		var e = document.createElement("div");
		e.setAttribute("class", a);
		document.body.appendChild(e);
		setTimeout(function() {
			document.body.removeChild(e)
		}, 100)
	}
 
	function d(e) {
		return {
			height : e.offsetHeight,
			width : e.offsetWidth
		}
	}
 
	function v(i) {
		var s = d(i);
		return s.height > e && s.height < n && s.width > t && s.width < r
	}
 
	function m(e) {
		var t = e;
		var n = 0;
		while (!!t) {
			n += t.offsetTop;
			t = t.offsetParent
		}
		return n
	}
 
	function g() {
		var e = document.documentElement;
		if (!!window.innerWidth) {
			return window.innerHeight
		} else if (e && !isNaN(e.clientHeight)) {
			return e.clientHeight
		}
		return 0
	}
 
	function y() {
		if (window.pageYOffset) {
			return window.pageYOffset
		}
		return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
	}
 
	function E(e) {
		var t = m(e);
		return t >= w && t <= b + w
	}
 
	function S() {
		var e = document.createElement("audio");
		e.setAttribute("class", l);
		e.src = i;
		e.loop = false;
		e.addEventListener("canplay", function() {
			setTimeout(function() {
				x(k)
			}, 500);
			setTimeout(function() {
				N();
				p();
				for (var e = 0; e < O.length; e++) {
					T(O[e])
				}
			}, 15500)
		}, true);
		e.addEventListener("ended", function() {
			N();
			h()
		}, true);
		e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
		document.body.appendChild(e);
		e.play()
	}
 
	function x(e) {
		e.className += " " + s + " " + o
	}
 
	function T(e) {
		e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
	}
 
	function N() {
		var e = document.getElementsByClassName(s);
		var t = new RegExp("\\b" + s + "\\b");
		for (var n = 0; n < e.length; ) {
			e[n].className = e[n].className.replace(t, "")
		}
	}
 
	var e = 30;
	var t = 30;
	var n = 350;
	var r = 350;
	var i = "//ojp9dzqic.bkt.clouddn.com/high_background.mp3";
	var s = "mw-harlem_shake_me";
	var o = "im_first";
	var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
	var a = "mw-strobe_light";
	var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";
	var l = "mw_added_css";
	var b = g();
	var w = y();
	var C = document.getElementsByTagName("*");
	var k = null;
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			if (E(A)) {
				k = A;
				break
			}
		}
	}
	if (A === null) {
		console.warn("Could not find a node of the right size. Please try a different page.");
		return
	}
	c();
	S();
	var O = [];
	for (var L = 0; L < C.length; L++) {
		var A = C[L];
		if (v(A)) {
			O.push(A)
		}
	}
})()    '>High一下</a> </li>

  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
		
          <time datetime="2018-04-30T16:00:00.000Z"><a href="/2018/05/01/学习/找工作/Java开发复习资料/">2018-05-01</a></time>
        
	  
      
  
    <h1 class="title">Java开发复习资料</h1>
  

    </header>
    <div class="entry">
         
        
    <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#在被虐中成长，在面试中进步"><span class="toc-text">在被虐中成长，在面试中进步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-更加集中的学习"><span class="toc-text">1. 更加集中的学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-更加系统的知识体系"><span class="toc-text">2. 更加系统的知识体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-弥补不足，提升自我"><span class="toc-text">3. 弥补不足，提升自我</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-更加深入地了解知识背后原理"><span class="toc-text">4. 更加深入地了解知识背后原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缘分与心态"><span class="toc-text">缘分与心态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础备战"><span class="toc-text">基础备战</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章-操作系统"><span class="toc-text">第一章 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-生产者与消费者"><span class="toc-text">1.1 生产者与消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#背景"><span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式"><span class="toc-text">实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-常见面试题"><span class="toc-text">1.2 常见面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3进程和线程"><span class="toc-text">1.3进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-线程"><span class="toc-text">1.1 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-进程"><span class="toc-text">1.2 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-进程和线程的关系："><span class="toc-text">1.3 进程和线程的关系：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-进程与线程的区别"><span class="toc-text">1.4 进程与线程的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-IPC几种通信方式-进程间的通信方式"><span class="toc-text">2. IPC几种通信方式(进程间的通信方式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-死锁的必要条件和处理死锁。"><span class="toc-text">3. 死锁的必要条件和处理死锁。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Window内存管理方式：页存储、段存储、段页存储。"><span class="toc-text">1.4 Window内存管理方式：页存储、段存储、段页存储。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-分页存储管理"><span class="toc-text">1.4.1 分页存储管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-分段存储"><span class="toc-text">1.4.2 分段存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-分页和分段的主要区别"><span class="toc-text">1.4.3 分页和分段的主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-段页存储"><span class="toc-text">1.4.4 段页存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-虚拟内存。"><span class="toc-text">1.5 虚拟内存。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-操作系统如何进行分页调度"><span class="toc-text">1.6 操作系统如何进行分页调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-磁盘调度算法："><span class="toc-text">1.7 磁盘调度算法：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第二章-计算机网络"><span class="toc-text">第二章 计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-OSI（开放系统互联参考模型）标准模型"><span class="toc-text">2.1 OSI（开放系统互联参考模型）标准模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-IP地址分类"><span class="toc-text">2.2 IP地址分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-ARP地址解析协议"><span class="toc-text">2.3 ARP地址解析协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-交换机、路由器、网关"><span class="toc-text">2.4 交换机、路由器、网关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-OSI-和TCP-IP的区别"><span class="toc-text">2.5 OSI 和TCP/IP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-TCP与UDP的区别"><span class="toc-text">2.6 TCP与UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-常见的路由选择协议，以及它们的区别"><span class="toc-text">2.7 常见的路由选择协议，以及它们的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-TCP的三次握手与四次挥手过程"><span class="toc-text">2.8 TCP的三次握手与四次挥手过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-TCP拥塞控制"><span class="toc-text">2.9 TCP拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-HTTP"><span class="toc-text">2.10 HTTP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-各种协议"><span class="toc-text">2.11 各种协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章-算法与数据结构"><span class="toc-text">第三章 算法与数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-0-知识点汇总"><span class="toc-text">3.0 知识点汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-排序算法"><span class="toc-text">3.1 排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-直接插入排序"><span class="toc-text">1.直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-希尔排序"><span class="toc-text">2.希尔排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-冒泡排序"><span class="toc-text">3.冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-快速排序"><span class="toc-text">4.快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-直接选择排序"><span class="toc-text">5.直接选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-堆排序"><span class="toc-text">6.堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-归并排序"><span class="toc-text">7.归并排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-查找"><span class="toc-text">3.2 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-顺序查找"><span class="toc-text">1. 顺序查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-二分查找"><span class="toc-text">2. 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-hash-算法"><span class="toc-text">3. hash 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-二叉树搜索树"><span class="toc-text">4. 二叉树搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-AVL查找树"><span class="toc-text">5. AVL查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-B-树（B树）"><span class="toc-text">6. B-树（B树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-B-树"><span class="toc-text">7. B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-红黑树"><span class="toc-text">8 . 红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-哈夫曼树"><span class="toc-text">9.  哈夫曼树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-字符串"><span class="toc-text">3.3 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找树"><span class="toc-text">查找树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子字符串查找"><span class="toc-text">子字符串查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-图"><span class="toc-text">3.4 图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5剑指offer"><span class="toc-text">3.5剑指offer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Leetcode"><span class="toc-text">3.6 Leetcode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章-JAVA基础"><span class="toc-text">第四章 JAVA基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-j2se基础"><span class="toc-text">4.1 j2se基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-面向对象"><span class="toc-text">4.2 面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-集合"><span class="toc-text">4.3 集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-多线程"><span class="toc-text">4.4 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-IO"><span class="toc-text">4.5 IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-设计模式"><span class="toc-text">4.6 设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-JVM"><span class="toc-text">4.7 JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM常用参数配置"><span class="toc-text">JVM常用参数配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章-数据库"><span class="toc-text">第五章 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#存储引擎的区别"><span class="toc-text">存储引擎的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM和InnoDB的区别"><span class="toc-text">MyISAM和InnoDB的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sql注入原理"><span class="toc-text">sql注入原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库索引"><span class="toc-text">数据库索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库锁机制"><span class="toc-text">数据库锁机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库连接池原理"><span class="toc-text">数据库连接池原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-框架和组件"><span class="toc-text">第六章 框架和组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-spring"><span class="toc-text">6.1 spring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-spring-MVC"><span class="toc-text">6.2 spring-MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Mybatis"><span class="toc-text">6.3 Mybatis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章-面试"><span class="toc-text">第七章 面试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-语言基础"><span class="toc-text">7.1 语言基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-算法"><span class="toc-text">7.2 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-项目"><span class="toc-text">7.3 项目</span></a></li></ol></li></ol>
    </div>

      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="在被虐中成长，在面试中进步"><a href="#在被虐中成长，在面试中进步" class="headerlink" title="在被虐中成长，在面试中进步"></a>在被虐中成长，在面试中进步</h2><p>指缝很宽，时间太瘦，悄悄从指缝间溜走。转眼之间三年的研究生生活即将结束，即使很是不舍，也终将要走向社会，开始另一段新的旅程。此刻，看着下一届师弟师妹开始忙碌地准备找实习，便开始追忆起过去一年找实习和工作的历程，那是一段艰辛而又成长颇多的经历。</p>
<p>过去一年找实习和工作的经历还是那么清晰，每每想起，都彷如发生在昨日。面试官问的问题以及那些踩过的坑却都一一浮现眼前，久久不能忘怀。那无数日夜挑灯备战的艰辛，那焦虑不安等着面试电话的心情，那一次次被被拒后的失落和那收到一个个offer喜悦之情，<strong>那些我们经历的终将成为我们人生一笔宝贵的财富</strong>。而最重要的是，我们在面试过程中学会了成长，学会了改变。学习弥补那些我们不会的知识，加深理解那些我们浮于表面的原理，改变我们面试过程中出现的缺点和不足。那段时间，我们快速吸收了大量知识，又好像重新回到了当年的考研状态，但又感觉比考研还要艰辛，因为要准备的知识面太多、太广。亦如考研，朝看夕忘，每天沉浸在复习和备战中。书本和笔记一遍遍地翻看，算法一遍遍地刷，又一遍遍地准备那些自己不擅长的知识。闲暇时便又去收集各种招聘信息，看看招聘网站是否有新的找人消息，问问学长学姐还有没有内推的机会。就这样一步一步，<strong>我们在被虐中成长，在面试中进步</strong>。面试是一个非常好的学习机会，我们应当适当地利用好这次机会完成自己知识的一次飞跃。</p>
<h4 id="1-更加集中的学习"><a href="#1-更加集中的学习" class="headerlink" title="1. 更加集中的学习"></a>1. 更加集中的学习</h4><p>正如考研、期末考试一样，面试也是我们一次知识增长和爆发的时候。因为有了面试和找工作的压力，我们便能更加集中地将大把时间花在学习和复习上。将时间花在哪里，你的成就就在哪里，根据《刻意练习》中的刻意练习理论和《异类》中的10000小时定律，你在某个领域花的时间越多，你在该领域的成就越高。</p>
<p>我们在面试过程中加强了知识复习强度，而面试就是对这次知识准备的反馈过程，通过面试来找出自己的不足和了解自己知识的掌握程度。遇到不会的知识，我们便开始上网或翻阅书本，查缺补漏。通过反复的准备、面试、纠正的过程使得我们掌握了大量的面试技巧，同时也强化了对知识掌握程度。</p>
<h4 id="2-更加系统的知识体系"><a href="#2-更加系统的知识体系" class="headerlink" title="2. 更加系统的知识体系"></a>2. 更加系统的知识体系</h4><p>互联网面试不会问单一的知识（如：算法），而是一次综合性考察。因此我们在备战面试过程中各个知识点都需要准备，如计算机操作系统、计算机网络、数据库、算法、数据结构等。而知识之间不可能孤立存在，而是彼此存在联系。《高效学习》中提到，学习过程分为几个阶段：<strong>知识获取,理解,拓展(或者建立联系),纠错,应用,记忆,测试</strong>。我们根据面试要求从相关书籍中<strong>获取知识</strong>；<strong>理解</strong>一些知识和概念，及背后的原理(如什么是面向对象)；同时建立起与其他知识之间的<strong>联系</strong>，例如java虚拟机的垃圾回收算法是什么，性能如何？优缺点是什么？—java虚拟机和算法数据结构的联系。java虚拟机如何做到跨平台，与计算机系统之间是怎样的关系等。通过面试过程<strong>纠正</strong>我们对知识的错误认知。通过反复纠正、记忆便掌握更加牢固。</p>
<p>面试中的问题都会将一些知识联系起来，比如MySql索引的数据结构是什么？性能如何？不同索引之间的比较如何？这些都不是单纯的考察MySql知识，同时也在考察对数据库中B+树、hash的理解。</p>
<p>可以通过复习建立起各个知识之间的联系，并且我们能够花大量时间系统的学习各个方面的知识。通过这样一次复习后，我们拥有了更加系统的互联网知识体系，建立起各知识点之间的联系。</p>
<h4 id="3-弥补不足，提升自我"><a href="#3-弥补不足，提升自我" class="headerlink" title="3. 弥补不足，提升自我"></a>3. 弥补不足，提升自我</h4><p>面试一个非常好的地方就是能够帮助自己，找出自己的不足，这些不足包括知识和沟通等方面。面试中遇到不会的问题便是我们成长最大、最快的地方。这些问题之前学习的时候是否认真考虑过？是否做项目时，某些问题是否有深入地分析过？用的框架是否知其然而知其所以然？总结面试中回答不足的问题，我们在复习过程中重点攻克，查缺补漏，进一步巩固之前的基础知识。虽然面试过程中有时候会被虐的体无完肤，虐得心力憔悴。但是，这也帮助我们找到自己知识的不足，便于弥补和提高。面试过程中最怕的不是被拒绝，而是不知道为什么被拒绝。被拒绝后还不采取相应的措施去做出改变，那即便面再多也是徒然。</p>
<h4 id="4-更加深入地了解知识背后原理"><a href="#4-更加深入地了解知识背后原理" class="headerlink" title="4. 更加深入地了解知识背后原理"></a>4. 更加深入地了解知识背后原理</h4><p>通常我们掌握的知识，仅仅是这个知识，处于一种<strong>见树而不见森林</strong>的状态，对其别后的原理和联系都不甚了解。于是面试中一旦面试官深入问询时，自己便回答不上了。<strong>面试带来的好处就是让我们有更多的机会去反思和思考，让我们能够更加深入地去挖掘知识背后的原理，而不是简简单单地浮于表面的理解</strong>。面试中你会发现那些习以为常的知识背后隐藏着一个丰富多彩的知识世界，<strong>一花一世界，一叶一森林</strong>，这些知识背后总有那些需要了解的知识原理和知识间的联系。通过面试，我们加强对这些知识的理解和学习，通过深入分析背后的原理和建立起知识点的练习，使自己能够做到<strong>见树即见森林</strong>。</p>
<p>面试是一次知识提升的机会，面试中应该学会总结自己的不足，并针对不足之处深入研究、分析才能促进自己的成长。而不应该仅仅将面试准备当做应付考试一样准备，背背网上的一些所谓的”标准答案“。</p>
<h2 id="缘分与心态"><a href="#缘分与心态" class="headerlink" title="缘分与心态"></a>缘分与心态</h2><p>我们如此看重实习和工作，是因为进入BAT等互联网大型公司实习一方面能够给我们一个平台提高我们的实践能力、学习更多知识技能和拓展我们的视野，另一方面是能在未来找工作时为我们简历加分。而工作更不用说了，十几年的学习生涯也是为了毕业时找份好工作，为未来奠定一个好的开端。很多人常说第一份工作至关重要，往往决定了一个人未来的发展道路。是否决定一个人未来因个人而异，但是第一份工作还是非常关键，那是我们走入社会的第一步，会对自己个人的成长和视野的开拓产生重要影响。因为不同的公司的文化环境不同，组织结构不同和给个人提供的机会都有所不同。因此也很多人格外看重这份工作。</p>
<p>而不管是找实习还是找工作，我们都会面临一个问题，那就是面试。面试不仅是考验的是技术和知识，同时也是看缘分和心态。</p>
<p>找工作之前，有一点你必须清楚，就是找工作是一件看缘分的事情，不是你很牛逼，你就一定能进你想进的公司，都是有一个概率在那。比如相同的公司因为面试官不同问的知识点也可能不同，有时候问的刚好你都准备了，有时候偏偏问些你所不会的。如果你基础好，项目经验足，同时准备充分，那么你拿到offer的概率就会比较高；相反，如果你准备不充分，基础也不好，那么你拿到offer的概率就会比较低，但是你可以多投几家公司，这样拿到offer的几率就要大一点，因为你总有运气好的时候。所以，不要惧怕面试，刚开始失败了没什么的，多投多尝试，面多了你就自然能成面霸了。<strong>得失心也不要太重</strong>，应该放宽心态，应为最后每个人都会有offer的。</p>
<h2 id="基础备战"><a href="#基础备战" class="headerlink" title="基础备战"></a>基础备战</h2><p>基础这东西，各个公司都很看重，尤其是BAT这种大公司，他们看中人的潜力，他们舍得花精力去培养，所以基础是重中之重。当你的基础好的发指的时候，你的其他东西都不重要了。</p>
<p>基础无外乎几部分：语言（C/C++或java），操作系统，TCP/IP，数据结构与算法，再加上你所熟悉的领域。当面试多了，你便会发现有很多是常见的问题和知识点，因此本书对那些常见的面试题进行收集和整理，并对一些题目做深入分析，希望能够帮助大家。</p>
<hr>
<h1 id="第一章-操作系统"><a href="#第一章-操作系统" class="headerlink" title="第一章 操作系统"></a>第一章 操作系统</h1><h2 id="1-1-生产者与消费者"><a href="#1-1-生产者与消费者" class="headerlink" title="1.1 生产者与消费者"></a>1.1 生产者与消费者</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。解决生产者/消费者问题的方法可分为两类： 1.采用某种机制保护生产者和消费者之间的同步； 2.在生产者和消费者之间建立一个管道。第一种方式有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>同步方式实现生产者-消费者模型。在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。 </p>
<ul>
<li>wait() / notify()方法 </li>
<li>await() / signal()方法 </li>
<li>BlockingQueue阻塞队列方法 </li>
<li><p>PipedInputStream / PipedOutputStream</p>
<p>wait()/notify() 、blockingQueue方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">MsgQueueManager</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 消息总队列</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">final</span> BlockingQueue&lt;T&gt; messageQueue;</div><div class="line">        MsgQueueManager(BlockingQueue&lt;T&gt; messageQueue) &#123;</div><div class="line">            <span class="keyword">this</span>.messageQueue = messageQueue;</div><div class="line">        &#125;</div><div class="line">        MsgQueueManager() &#123;</div><div class="line">            <span class="keyword">this</span>.messageQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;T&gt;();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                messageQueue.put(msg);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                Thread.currentThread().interrupt();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> messageQueue.take();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                Thread.currentThread().interrupt();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> MsgQueueManager msgQueueManager;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(MsgQueueManager msgQueueManager)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.msgQueueManager = msgQueueManager;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            msgQueueManager.put(<span class="keyword">new</span> Object());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> MsgQueueManager msgQueueManager;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(MsgQueueManager msgQueueManager)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.msgQueueManager = msgQueueManager;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Object o = msgQueueManager.take();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MsgQueueManager&lt;String&gt; msgQueueManager = <span class="keyword">new</span> MsgQueueManager&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</div><div class="line">            <span class="keyword">new</span> Producer(msgQueueManager).start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</div><div class="line">            <span class="keyword">new</span> Consumer(msgQueueManager).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-2-常见面试题"><a href="#1-2-常见面试题" class="headerlink" title="1.2 常见面试题"></a>1.2 常见面试题</h2><ul>
<li>进程和线程的区别。</li>
<li>死锁的必要条件，怎么处理死锁。</li>
<li>Window内存管理方式：段存储，页存储，段页存储。</li>
<li>进程的几种状态。</li>
<li>IPC几种通信方式。</li>
<li>什么是虚拟内存。</li>
<li>虚拟地址、逻辑地址、线性地址、物理地址的区别。</li>
</ul>
<h2 id="1-3进程和线程"><a href="#1-3进程和线程" class="headerlink" title="1.3进程和线程"></a>1.3进程和线程</h2><h4 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h4><p><strong>概念</strong>：线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p>
<p><strong>好处</strong>：<strong>1)</strong>易于调度。 <strong>2)</strong>提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。 <strong>3)</strong>开销少。创建线程比创建进程要快，所需开销很少。。 <strong>4)</strong>利于充分发挥多处理器的功能。通过创建多线程进程，每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。</p>
<p> <strong>线程状态：</strong>联系java中线程的几种状态 ，java thread的运行周期中的几种状态,在 <code>java.lang.Thread.State</code> 中有详细定义和说明:</p>
<ol>
<li>NEW 状态是指线程刚创建, 尚未启动</li>
<li>RUNNABLE 状态是线程正在正常运行中,当然可能会有某种耗时计算/IO等待的操作/CPU时间片切换等,这个状态下发生的等待一般是其他系统资源, 而不是锁, Sleep等</li>
<li>BLOCKED 这个状态下, 是在多个线程有同步操作的场景,比如正在等待另一个线程的synchronized 块的执行释放, 或者可重入的 synchronized块里别人调用wait() 方法,也就是这里是线程在等待进入临界区</li>
<li>WAITING 这个状态下是指线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作, 这里要区分 BLOCKED 和 WATING 的区别, 一个是在临界点外面等待进入, 一个是在理解点里面wait等待别人notify, 线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束</li>
<li>TIMED_WAITING 这个状态就是有限的(时间限制)的WAITING, 一般出现在调用wait(long), join(long)等情况下, 另外一个线程sleep后, 也会进入TIMED_WAITING状态</li>
<li>TERMINATED 这个状态下表示该线程的run方法已经执行完毕了,基本上就等于死亡了(当时如果线程被持久持有, 可能不会被回收) </li>
</ol>
<h4 id="1-2-进程"><a href="#1-2-进程" class="headerlink" title="1.2 进程"></a>1.2 进程</h4><p><strong>概念：</strong>进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程,在这个过程中，伴随着资源的分配和释放。可以认为进程是一个程序的一次执行过程。</p>
<ul>
<li><strong>进程与程序的区别</strong></li>
</ul>
<ol>
<li>进程是程序的一次运行活动，属于一种动态的概念。程序是一组有序的静态指令，是一种静态的概念。</li>
<li>一个进程可以执行一个或多个程序。</li>
<li>程序可以作为一种软件资源长期保持着,而进程则是一次执行过程,它是暂时的,是动态地产生和终止的。</li>
<li>进程更能真实地描述并发,而程序不能。</li>
<li>进程由程序和数据两部分组成，进程是竞争计算机系统有限资源的基本单位</li>
<li>进程具有创建其他进程的功能；而程序没有。</li>
<li>进程还具有并发性和交互性，这也与程序的封闭性不同</li>
</ol>
<ul>
<li><strong>进程的几种状态:</strong></li>
</ul>
<ol>
<li>创建状态(New)：进程正在创建过程中，还不能运行。操作系统在创建状态要进行的工作包括分配和建立进程控制块表项、建立资源表格(如打开文件表)并分配资源、加载程序并建立地址空间表等。</li>
<li>就绪状态(Ready)：进程已获得除处理器外的所需资源，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排人低优先级队列；当进程由I／O操作完成而进入就绪状态时，排入高优先级队列。</li>
<li>执行状态:进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。</li>
<li>阻塞状态:正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态，有时也称为等待状态或封锁状态。致使进程阻塞的典型事件有：请求I/O，申请缓冲空间等。通常将这种处于阻塞状态的进程也排成一个队列。有的系统则根据阻塞原因的不同而把处于阻塞状态的进程排成多个队列。</li>
<li>退出状态(Exit)：进程已结束运行，回收除进程控制块之外的其他资源，并让其他进程从进程控制块中收集有关信息(如记帐和将退出代码传递给父进程)。</li>
</ol>
<ul>
<li><strong>作业(进程)调度算法</strong></li>
</ul>
<ol>
<li>先来先服务调度算法(FCFS) 每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</li>
<li>短作业(进程)优先调度算法(SPF) 短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。缺点:长作业的运行得不到保证</li>
<li>优先权调度算法(HPF) 当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。 可以分为: 1.非抢占式优先权算法 2.抢占式优先权调度算法</li>
<li>高响应比优先调度算法(HRN) 每次选择高响应比最大的作业执行，响应比=(等待时间+要求服务时间)/要求服务时间。该算法同时考虑了短作业优先和先来先服务。<ul>
<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</li>
<li>当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</li>
<li>对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</li>
</ul>
</li>
<li>时间片轮转法（RR） 在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</li>
<li>多级反馈队列调度算法 它是目前被公认的一种较好的进程调度算法。<ul>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>作业与进程的区别</strong></p>
<p>一个进程是一个程序对某个数据集的执行过程，是分配资源的基本单位。作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。一个作业的完成要经过作业提交、作业收容、作业执行和作业完成4个阶段。而进程是对已提交完毕的程序所执行过程的描述，是资源分配的基本单位。</p>
<ul>
<li>作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业后，系统将它放入外存中的作业等待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。</li>
<li>一个作业可由多个进程组成，且必须至少由一个进程组成，反过来则不成立。</li>
<li>作业的概念主要用在批处理系统中，像UNIX这样的分时系统中就没有作业的概念。而进程的概念则用在几乎所有的多道程序系统中。</li>
</ul>
</li>
</ul>
<h4 id="1-3-进程和线程的关系："><a href="#1-3-进程和线程的关系：" class="headerlink" title="1.3 进程和线程的关系："></a>1.3 进程和线程的关系：</h4><ul>
<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</li>
<li>处理机分给线程，即真正在处理机上运行的是线程。</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体.</li>
</ul>
<h4 id="1-4-进程与线程的区别"><a href="#1-4-进程与线程的区别" class="headerlink" title="1.4 进程与线程的区别"></a>1.4 进程与线程的区别</h4><ul>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位</li>
<li>并发性:不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</li>
<li>拥有资源:进程是拥有资源的一个独立单位，线程不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源.</li>
<li>系统开销:由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置。而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此，这些线程之间的同步与通信非常容易实现，甚至无需操作系统的干预。</li>
<li>通信方面：进程间通讯有管道、信号量、信号消息队列、socket来维护，而线程间通过通道、共享内存、信号灯来进行通信。</li>
</ul>
<h3 id="2-IPC几种通信方式-进程间的通信方式"><a href="#2-IPC几种通信方式-进程间的通信方式" class="headerlink" title="2. IPC几种通信方式(进程间的通信方式)"></a>2. IPC几种通信方式(进程间的通信方式)</h3><ul>
<li><p><strong>管道( pipe )</strong>：只支持半双工通信方式，即只能单向传输；只能在父子进程之间使用。</p>
<p>管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。</p>
<p>流管道：去除第一个限制，支持双向传输；</p>
<p>命名管道：去除第二个限制，可以在不相关进程之间进行通信。</p>
</li>
<li><p>命名管道 (named pipe)： 命名管道也是半双工的通信方式，它克服了管道没有名字的限制，并且它允许无亲缘关系进程间的通信。命令管道在文件系统中有对应的文件名，命名管道通过命令mkfifo或系统调用mkfifo来创建。</p>
</li>
<li><p>信号量( semophore )： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li><p>消息队列( message queue )： 消息队列是由消息的链表结构实现，存放在内核中并由消息队列标识符标识。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p>信号 ( sinal )：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。除了用于进程通信外，进程还可以发送信号给进程本身。</p>
</li>
<li><p>共享内存( shared memory )：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</p>
</li>
<li><p>套接字( socket )： 也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
</li>
</ul>
<h3 id="3-死锁的必要条件和处理死锁。"><a href="#3-死锁的必要条件和处理死锁。" class="headerlink" title="3. 死锁的必要条件和处理死锁。"></a>3. 死锁的必要条件和处理死锁。</h3><p><strong>死锁概念</strong>：两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p>
<p><strong>活锁</strong> ：活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败</p>
<p><strong>死锁条件</strong> ：</p>
<ul>
<li>互斥条件:一个资源每次只能被一个进程使用</li>
<li>不可剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺</li>
<li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系.</li>
</ul>
<p><strong>死锁预防</strong> ：</p>
<ul>
<li>破坏互斥条件。允许某些进程(线程)同时访问某些资源，但有的资源不允许同时被访问如打印机等。</li>
<li>破坏不可抢占条件:即允许进程强行从占有者那里夺取某些资源。实现起来困难，会降低系统性能。</li>
<li><p>破坏占有且申请条件。可以实行预先分配策略，即进程在运行前一次性地向系统申请它所需要的全部资源。如果当前进程所需的全部资源得不到满足，则不分配任何资源。只有当系统能够满足当前的全部资源得到满足时，才一次性将所有申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又重新申请资源的现象，因此不会发生死锁。但是有以下缺点：</p>
<ul>
<li><p>由于进程在执行时是动态的，不可预测的,进程在执行之前不可能知道它所需的全部资源。</p>
</li>
<li><p>资源利用率低。无论所分配资源何时用到，一个进程只有在占有所需的全部资源后才能执行。即使有些资源最后才被该进程用到一次，但该进程在生存期间一直占有它们，造成长期占有。</p>
</li>
<li><p>降低了进程的并发性。因为资源有限，又加上存在浪费，能分配到所需全部资源的进程个数必然少了。</p>
</li>
</ul>
</li>
<li>破坏循环等待条件。实行资源有序分配策略。采用这种策略即把资源事先分类编号，按号分配。所有进程对资源的请求必须严格按资源需要递增的顺序提出。进程先占用小号资源，才能申请大号资源，就不会产生环路。这种策略与前面的策略相比，资源的利用率和系统吞吐量都有很大提高，但是也存在缺点：限制了进程对资源的请求，同时系统给所有资源合理编号也是件困难事，并增加了系统开销。</li>
</ul>
<p><strong>死锁的避免:</strong></p>
<ul>
<li>银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。</li>
</ul>
<p><strong>死锁的解除:</strong></p>
<ul>
<li>资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。</li>
<li>撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。</li>
<li>进程回退法。让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ul>
<p><strong>死锁检测与死锁恢复</strong>：</p>
<p>​    如果一个进程所请求的资源能够被满足，那么就让它执行，否则释放它拥有的所有资源，然后让其它能满足条件的进程执行。</p>
<h2 id="1-4-Window内存管理方式：页存储、段存储、段页存储。"><a href="#1-4-Window内存管理方式：页存储、段存储、段页存储。" class="headerlink" title="1.4 Window内存管理方式：页存储、段存储、段页存储。"></a>1.4 Window内存管理方式：页存储、段存储、段页存储。</h2><h3 id="1-4-1-分页存储管理"><a href="#1-4-1-分页存储管理" class="headerlink" title="1.4.1 分页存储管理"></a>1.4.1 分页存储管理</h3><p><strong>原理</strong>：将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)或物理块，每个物理块的大小一般取2的整数幂。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）。</p>
<p>逻辑地址-物理地址转换：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。</p>
<p><strong>优点</strong>  ：</p>
<p>1）没有外部碎片，提高内存的利用率。 2）一个程序不必连续存放。3）程序内存可以动态变化。</p>
<p><strong>缺点</strong> ： 1）页内部碎片，造成浪费。2）页长与程序的逻辑大小不相关。 3）不利于编程时的独立性，给换入换出、存储保护和存储共享等操作造成麻烦。</p>
<h3 id="1-4-2-分段存储"><a href="#1-4-2-分段存储" class="headerlink" title="1.4.2 分段存储"></a>1.4.2 分段存储</h3><p><strong>思想</strong> :将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中（写c程序时会用到），并且每个程序可以有多个相同类型的段。</p>
<p>在为某个段分配物理内存时，可以采用首先适配法、下次适配法、最佳适配法等方法。在回收某个段所占用的空间时，要注意将收回的空间与其相邻的空间合并。</p>
<p><strong>地址映射</strong>：逻辑地址由段号和段内地址两部分组成。为了完成进程逻辑地址到物理地址的映射，处理器会查找内存中的段表，由段号得到段的首地址，加上段内地址，得到实际的物理地址。</p>
<p><strong>优点</strong>：(1)段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。 (2)段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。 (3)方便编程，分段共享，分段保护，动态链接，动态增长</p>
<p><strong>缺点</strong>： (1)主存空间分配比较麻烦。 (2)有外部碎片。 </p>
<h3 id="1-4-3-分页和分段的主要区别"><a href="#1-4-3-分页和分段的主要区别" class="headerlink" title="1.4.3 分页和分段的主要区别"></a>1.4.3 分页和分段的主要区别</h3><ul>
<li>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；段则是信息的逻辑单位，它含有一组其意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。 </li>
<li>页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的；而段的长度却不固定，决定于用户所编写的程序和编译器。 </li>
<li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址是，即需给出段名，又需给出段内地址。 </li>
<li>分页信息很难保护和共享、分段存储按逻辑存储所以容易实现对段的保存和共享。</li>
</ul>
<h3 id="1-4-4-段页存储"><a href="#1-4-4-段页存储" class="headerlink" title="1.4.4 段页存储"></a>1.4.4 段页存储</h3><p><strong>原理</strong>：程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机制将段内位移量分解为页号和页内位移量。</p>
<p><strong>实现</strong> ：为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块。</p>
<p>将程序按逻辑结构划分为若干个逻辑段，然后再将每个逻辑段划分为若干个大小相等的逻辑页。每个程序段对应一个段表，每页对应一个页表。主存空间也划分为若干个物理页。</p>
<p><strong>地址变换</strong> ：</p>
<p>1) 利用段表始址和段号来求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址</p>
<p>2) 利用逻辑地址中的段内页号P来获得对应页的页表项位置，从中读出该页所在的物理块号b</p>
<p>3）再利用块号b和页内地址来构成物理地址。</p>
<p><strong>优缺点</strong> ： 段页存储管理方式综合了段式管理和页式管理的优点，但需要经过两级查表才能完成地址转换，消耗时间多。</p>
<ul>
<li>优点 (1) 它提供了大量的虚拟存储空间。 (2) 能有效地利用主存，为组织多道程序运行提供了方便。</li>
<li>缺点： (1) 增加了硬件成本、系统的复杂性和管理上的开消。 (2) 存在着系统发生抖动的危险。 (3) 每段最后一页可能有内部碎片。 </li>
</ul>
<h2 id="1-5-虚拟内存。"><a href="#1-5-虚拟内存。" class="headerlink" title="1.5 虚拟内存。"></a>1.5 虚拟内存。</h2><ul>
<li>物理内存: 真实硬件内存可用大小，CPU的地址线可以直接进行寻址的内存空间大小。</li>
<li>虚拟内存: 它使得应用程序认为它拥有连续的可用的内存(一个连续完整的地址空间),而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</li>
</ul>
<h2 id="1-6-操作系统如何进行分页调度"><a href="#1-6-操作系统如何进行分页调度" class="headerlink" title="1.6 操作系统如何进行分页调度"></a>1.6 操作系统如何进行分页调度</h2><ul>
<li>先进先出算法(FIFO):在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。</li>
<li>最优置换算法（OPT）:所选择的老页应是将来不再被使用，或者是在最远的将来才被访问。采用这种页面置换算法，保证有最少的缺页率。 但是最优页面置换算法的实现是困难的，因为它需要人们预先就知道一个进程整个运行过程中页面走向的全部情况。</li>
<li>LRU（最近最少使用）：如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。</li>
<li>时钟算法: 又称为最近未用(Not Recently Used, NRU)算法。</li>
</ul>
<h2 id="1-7-磁盘调度算法："><a href="#1-7-磁盘调度算法：" class="headerlink" title="1.7 磁盘调度算法："></a>1.7 磁盘调度算法：</h2><ul>
<li>先来先服务（FCFS），按访问请求到达的先后顺序服务。简单，公平，但是效率不高，相临两次请求可能会造成最内到最外柱面寻道，使磁头反复移动，增加了服务时间，对机器不利。</li>
<li>最短寻道时间优先(SSTF)，优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先。改善了磁盘平均服务时间，但是造成某些访问请求长期等待得不到服务。</li>
<li>扫描算法（SCAN）当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务.</li>
<li>循环扫描算法（CSCAN）：磁臂改为单项移动，由外向里。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</li>
</ul>
<hr>
<h1 id="第二章-计算机网络"><a href="#第二章-计算机网络" class="headerlink" title="第二章 计算机网络"></a>第二章 计算机网络</h1><h2 id="2-1-OSI（开放系统互联参考模型）标准模型"><a href="#2-1-OSI（开放系统互联参考模型）标准模型" class="headerlink" title="2.1 OSI（开放系统互联参考模型）标准模型"></a>2.1 OSI（开放系统互联参考模型）标准模型</h2><p><strong>物理层</strong> 负责为数据端设备透明地传输原始比特流，并且定义了数据终端设备和数据通信设备的物理和逻辑链接方法。传输单位是比特。 协议：RJ45、CLOCK、IEEE802.3 设备：（中继器，集线器） </p>
<p><strong>数据链路层</strong> 将网络层传下来的IP数据报组装成帧，并检测和矫正物理层产生的传输差错，使得链路对网络层显示一条无差错、可靠的数据传输线路。功能可以概括为成帧，差错控制、流量控制和传输管理 协议有：HDLC(高级数据链路控制协议),PPP,STP,SDLC,CSMA(载波监听多路访问) 设备:（网桥，交换机） </p>
<p><strong>网络层</strong> 负载在网络层上将数据封装成数据报，将数据报从源端传到目的端，同时进行路由选择，为分组交换网上的不同主机提供通信服务。关键问题是对分组进行选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。传输单位数据报。 协议: IP,ICMP(因特网控制报文协议),IGMP(因特网组管理协议),ARP,RARP,OSPF(开放最短路径优先),IPX 设备:路由器 </p>
<p><strong>传输层</strong> 负责主机中两个进程之间的通信，为端到端连接提供可靠的传输服务。为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 协议：TCP,UDP </p>
<p><strong>会话层</strong> 会话层允许不同主机上各个进程之间的<strong>会话</strong>，会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要是为表示层实体或用户进程<strong>建立连接</strong>并在连接上提供<strong>有序</strong>地传输数据。 协议：SQL、RPC(远程调用协议) </p>
<p><strong>表示层</strong> 用于处理两个通信系统中交换信息的表示方式。如数据压缩，加密和解密等。 协议：JPEG、MPEG、ASII </p>
<p><strong>应用层</strong> 是TCP/IP的最高层，它是直接为应用进程服务的一层。当不同的应用进程数据通信或数据交换时，就去调用应用层的<strong>不同协议实体</strong>，让这些实体去调用TCP或者UDP层服务来进行网络传输。 协议：FTP(21) TELNET(23) SMTP(25) DNS(53) TFTP(69) HTTP(80) SNMP(161),DHCP(动态主机配置协议)</p>
<p><strong>TCP/IP 分层</strong>：</p>
<p>1）<strong>网络接口层（接收和发送数据报）</strong> 负责将数据报发送到<strong>网络介质</strong>上，以及从网络上接收TCP/IP数据报，相当于OSI的物理层和数据层。 2）<strong>网际层（数据报封装和路由寻址功能）</strong> 主要负责寻址和对数据报的封装以及重要的路由选择功能。 3)<strong>传输层</strong> <strong>负责在应用进程之间的“端到端”的通信</strong>，即从某个应用进程传输到另一个应用进程。 <strong>4)应用层</strong> 是TCP/IP的最高层，它是直接为应用进程服务的一层。当不同的应用进程数据通信或数据交换时，就去调用应用层的<strong>不同协议实体</strong>，让这些实体去调用TCP或者UDP层服务来进行网络传输。</p>
<p><strong>五层体系结构模型</strong>：物理层，数据链路层，网络层，传输层，应用层</p>
<h2 id="2-2-IP地址分类"><a href="#2-2-IP地址分类" class="headerlink" title="2.2 IP地址分类"></a>2.2 IP地址分类</h2><p>A类地址：以0开头， 第一个字节范围：1~126（1.0.0.0 - 126.255.255.255）； B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； D类地址：1110开头， 224~239 E类地址：11110开头， 240~255 主机号全为0表示本网络本身 ，主机号全为1表示本网络广播地址 。</p>
<p>127.0.0.0 环路自检地址，32个0 表示本网络的本主机 32个1表示整个TCP/IP网络的广播地址,等效本网络的广播地址。 专用地址： 10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部） IP地址与子网掩码相与得到网络号</p>
<h2 id="2-3-ARP地址解析协议"><a href="#2-3-ARP地址解析协议" class="headerlink" title="2.3 ARP地址解析协议"></a>2.3 ARP地址解析协议</h2><p><strong>本局域网上</strong>各主机和路由器的<strong>IP地址到MAC地址的映射表</strong>，称为ARP表。使用ARP协议动态维护此表。 ARP工作在网络层中，其工作原理是：当主机A欲向本局域网上的某个主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如果有可以查出其对应的硬件地址，再将此硬件地址写入<strong>MAC帧</strong>，然后通过局域网将该MAC帧发往此硬件地址。如果没有，就通过使用目的MAC地址为本网络的广播地址即32个1的帧来封装并广播ARP请求分组，可以使同一个局域网里的所有主机收到ARP请求。当主机B收到该ARP请求后，就会向主机A发出响应ARP分组，分组中包含主机B的IP与MAC地址的映射关系，主机A在收到后将此映射写入ARP缓存中，然后按查询到的硬件地址发送MAC帧。</p>
<p><strong>ARP是解决同一个局域网上主机与路由器的IP地址和硬件地址的映射问题</strong>。如果所要找的主机和源主机不在同一个局域网上，那么通过ARP协议找到一个位于本局域网上的某个路由器硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。</p>
<h2 id="2-4-交换机、路由器、网关"><a href="#2-4-交换机、路由器、网关" class="headerlink" title="2.4 交换机、路由器、网关"></a>2.4 交换机、路由器、网关</h2><p><strong>路由器</strong>是连接不同的网络并完成路由转发。</p>
<p><strong>交换机</strong>：是多个端口的网桥，工作在数据链路上，<strong>将两个或多个以太网连接起来成为更大的以太网。它能将网络分成小的冲突域，为每个工作站提供更高的带宽</strong>。其原理是，检测从以太端口来的数据帧的源和目的地的MAC地址，然后与系统内部的动态查找表进行比较。若数据帧的MAC地址不在查找表中，则将该地址加入查找表中，并将数据帧发送给相应的端口。</p>
<p>区别： <strong>路由器</strong>：工作在网络层，是能够连接不同的广域网形成更大的广域网。连接的是异构网络。根据IP地址转发。 <strong>交换机</strong>：工作在数据链路层，是将以太网连接形成更大的以太网，同一个网络。根据MAC地址进行转发。</p>
<p><strong>网关(Gateway)</strong> 仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。</p>
<h2 id="2-5-OSI-和TCP-IP的区别"><a href="#2-5-OSI-和TCP-IP的区别" class="headerlink" title="2.5 OSI 和TCP/IP的区别"></a>2.5 OSI 和TCP/IP的区别</h2><ol>
<li>OSI精确定义了服务、协议和接口，符合<strong>面向对象</strong>程序设计思想。而TCP/IP在这些概念上没有明确区分。</li>
<li>TCP/IP先有的协议，是事实标准。</li>
<li>TCP/IP考虑了异构网的互联问题，而OSI只考虑用一种标准的公用数据网将各种不同系统互连。</li>
</ol>
<h2 id="2-6-TCP与UDP的区别"><a href="#2-6-TCP与UDP的区别" class="headerlink" title="2.6 TCP与UDP的区别"></a>2.6 TCP与UDP的区别</h2><p>1、TCP<strong>面向连接</strong>;UDP是<strong>无连接的</strong>，即发送数据之前不需要建立连接 2、TCP提供可靠<strong>全双功</strong>的通信服务。UDP是半双功，只能单向传播。 3、通过TCP连接可靠传送的数据，<strong>可靠的</strong>、无差错，不丢失，不重复，且按序到达;UDP则是<strong>不可靠信道</strong>，尽最大努力交付，即不保证可靠交付. 4、TCP<strong>面向字节流</strong>，实际上是TCP把数据看成一连串无结构的字节流;UDP是<strong>面向报文</strong>的． 5、TCP具有<strong>拥塞控制</strong>，UDP<strong>没有拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 6、每一条TCP连接只能是<strong>点到点</strong>的;UDP比较灵活，支持一对一，一对多，多对一和多对多的交互通信 7、TCP首部开销20字节;UDP的首部开销小，只有8个字节.</p>
<p>TCP应用场景：效率要求相对低，但对准确性要求相对高的场景。如文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p>
<ul>
<li>FTP协议，21端口，文件传输</li>
<li>ssh： 22端口，远程登录及其他服务</li>
<li>Telnet：23端口，远程登录，明文传输，不安全。</li>
<li>SMTP： 25，发送邮件 POP3， 110，邮件接收。</li>
<li>HTTP：80，web文本传输协议， HTTPS， 443.</li>
</ul>
<p>UDP应用场景：效率要求相对高，对准确性要求相对低的场景。如：QQ聊天、在线视频、网络语音电话、广播通信。</p>
<ul>
<li>DNS(53)：用于域名解析服务，将域名地址转换为IP地址。 </li>
<li>RIP(520):路由信息协议 </li>
<li>SNMP(161)：简单网络管理协议，使用161号端口，是用来管理网络设备的。</li>
<li>TFTP(69)：简单文件传输协议。</li>
</ul>
<h2 id="2-7-常见的路由选择协议，以及它们的区别"><a href="#2-7-常见的路由选择协议，以及它们的区别" class="headerlink" title="2.7 常见的路由选择协议，以及它们的区别"></a>2.7 常见的路由选择协议，以及它们的区别</h2><p>常见的路由选择协议有：RIP协议、OSPF协议。 RIP协议（路由信息协议）：底层是贝尔曼福特算法(Bellman-Ford)，<strong>基于距离向量的路由选择协议</strong>，它选择路由的度量标准（metric)是<strong>跳数</strong>，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。仅和相邻路由器交换当前路由器所知道的全部信息。是应用层协议,使用UDP传输数据,端口520</p>
<p>OSPF协议（开放最短路由优先）：底层是迪杰斯特拉(Dijkstra)算法，<strong>是链路状态路由选择协议</strong>，它选择路由的度量标准是<strong>带宽</strong>，延迟。向本自治系统中所有路由器发送与本路由器相邻的所有路由器的链路状态，但这只是路由器知道的部分信息。网络层协议,直接IP数据报传输． 端口89</p>
<h2 id="2-8-TCP的三次握手与四次挥手过程"><a href="#2-8-TCP的三次握手与四次挥手过程" class="headerlink" title="2.8 TCP的三次握手与四次挥手过程"></a>2.8 TCP的三次握手与四次挥手过程</h2><p><strong>第一次握手</strong>：A向B发送一个连接请求报文段，其首部中同步位SYN被设置为1，序号seq=x，x为A随机生成的序号；</p>
<p><strong>第二次握手</strong>：B如果同意建立连接，就向A发回确认，并为该TCP连接分配缓存和变量。在确认报文段中，SYN和ACK位都被设置为1，确认号字段值为ack=x+1,并且服务器随机产生起始序号seq=y。</p>
<p><strong>第三次握手</strong>：当客户机A收到确认报文段后，还要向服务器给出确认，并且也要给该连接<strong>分配缓存和变量</strong>。这个报文段的确认位ACK被设置为1，序号段被设置为seq=x+1,确认号字段ack=y+1. 该报文段可以携带数据，如果不携带数据则不消耗序号。</p>
<p><strong>第一次挥手</strong>：A向B发送连接释放报文，并停止再发送数据，主动关闭TCP连接。结束标志位FIN被设置为1，seq=u,它等于前面已经发送过的数据的最后一个字节的序号加1。</p>
<p><strong>第二次挥手</strong>：B向A发出确认报文，确认号是ack=u+1,序号为v,等于它前面已经发送过的数据的最后一个字节序号加1.此时客户机到服务器这个方向的连接就释放了，TCP处于半关闭状态。ACK=1，seq=v,ack=u+1</p>
<p><strong>第三次挥手</strong>：若服务器B已经没有要向客户机A发送的数据，就通知TCP释放连接，此时发出FIN=1，确认号ack=u+1,序号seq=w,已经发送过的数据最后一个字节加1。确认为ACK=1. (FIN=1, ACK=1, seq=w, ack=u+1)</p>
<p><strong>第四次挥手</strong>：A客户机收到连接释放报文段后，必须向B发出确认。在确认报文段中，确认位ACK=1，序号seq=u+1,确认号ack=w+1. 此时连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL(Max Segment Lifetime),后，客户机才进入连接关闭状态。 (ACK=1,seq=u+1,ack=w+1)</p>
<p>不使用二次握手？防止因为网络延迟，导致服务端响应客户端的多个请求，并为其建立多个连接，浪费服务器资源。</p>
<p>为什么四次挥手，主动方要等待２MSL后才关闭连接？ 保证TCP协议的全双工连接能够可靠关闭．</p>
<h2 id="2-9-TCP拥塞控制"><a href="#2-9-TCP拥塞控制" class="headerlink" title="2.9 TCP拥塞控制"></a>2.9 TCP拥塞控制</h2><p><strong>拥塞控制</strong> ：使用四种算法：慢开始，拥塞避免，快重传，快恢复。 TCP要求发送端维护两个窗口： 1） 接收窗口rwnd，接收方根据当前缓存大小所许诺的最新窗口值。 2) 拥塞窗口 cwnd ,发送方根据自己估算的网络拥塞程度而设置的窗口值。 发送窗口的上限是取这两者的最小值。</p>
<ul>
<li><strong>慢开始</strong>： TCP刚连接好时，先令拥塞窗口cwnd =1 ,在每次收到一个对新报文段的确认时将cwnd加倍（因此是成倍增长2的n次方). cwnd的大小呈指数增长。</li>
<li><strong>拥塞避免算法</strong>： 当cwnd大于等于慢开始门限ssthresh时，cwnd窗口每次加1而不是加倍。当发送方检测到<strong>超时事件</strong>的发生时，就将慢开始门限设置为当前cwnd的一半，同时将cwnd设置为1. 这样的目的是迅速减少主机发送到网络的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。 </li>
<li><strong>快重传</strong>：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。 </li>
<li><strong>快恢复</strong>：当发送端收到连续三个冗余的ACK时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，cwnd设置为慢开始门限减半后的数值（与慢开始不同）。</li>
</ul>
<p>T<strong>CP滑动窗口与回退N针协议</strong></p>
<p><strong>滑动窗口</strong>： 发送方都维持一组连续的允许发送的帧的序号称为发送窗口。同时接收方也维持一组连续的允许接收的帧序号，称为接收窗口。发送窗口是用来对发送方进行流量控制，接收窗口是用来控制接收那些数据帧不可以接收那些帧。 在发送端，收到一个确认帧，发送窗口就向前滑动一个帧位置，当发送窗口没有可以发送的帧时，发送方就停止发送。直到接收方发送的确认帧使发送窗口向前移动。 在接收端，只有收到数据帧的序号落在接收窗口内才将该帧收下，否则一律丢弃。每收到一个帧后就发送回确认帧。</p>
<p><strong>后退N帧协议</strong> :发送窗口大于1，接收窗口等于1.在后退N帧中，发送方不需要收到上一帧的ACK后才能发送下一帧，而是可以连续发送帧。当接收方检测出失序信息帧后，要求发送方重发最后一个正确接收的帧之后的所有未被确认的帧。源站每发完一帧就要为该帧设置超时计时器，如果在超时时间内没有收到确认帧则进行重发。服务端会采用累积确认的方式，不是每个帧都发确认，可以连续收到好几个正确帧后发回一个确认信息。接收方因为窗口为1，所以必须按序接收数据帧，如果某个序大于当前所期望的序号时就会连续发送3个ACK确认帧，要求客户端重传失序帧。</p>
<p><strong>TCP的可靠性</strong></p>
<p>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。握手与断开都需要通讯双方确认，数据传输也需要双方确认成功，在协议中还规定了：分包、重组、重传等规则。</p>
<h2 id="2-10-HTTP"><a href="#2-10-HTTP" class="headerlink" title="2.10 HTTP"></a>2.10 HTTP</h2><p><strong>Http request类型</strong>：HTTP协议中共定义了八种方法或者叫“动作”来表明对Request-URI指定的资源的不同操作方式。GET， 向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除Request-URI所标识的资源。 HEAD：请求读取由URL所标志的信息的首部。 OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<p><strong>Http1.1和Http1.0的区别</strong>： </p>
<ol>
<li>HTTP1.0 是短连接，HTTP1.1是长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输。头部字段<code>Connection: keep-alive</code>。</li>
<li>HTTP 1.1中增加Host请求头字段后，实现了在IP端口上创建多个虚拟WEB站点。 </li>
<li>HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头 </li>
<li>带宽优化。HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。</li>
<li>HTTP/1.1增加了OPTIONS方法，它允许客户端获取一个服务器支持的方法列表。</li>
</ol>
<p><strong>Cookie与Session</strong>： </p>
<p>Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就产生一个用户身份标识，然后在响应消息中将该标识号以Cookie的形式传递给浏览器.客户端浏览器会把Cookie保存起来。浏览器在以后每次访问该web服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容. Cookie不能被浏览器共享 Cookie具有不可跨域名性，Cookie的maxAge决定着Cookie的有效期，单位为秒（Second） ，默认情况下用户退出浏览器后被删除。</p>
<p>Session是另一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，为了提高存取速度，服务器一般把Session放在内存里，每个用户都会有一个独立的Session ID， session也存在过期时间,通过cookie会刷新session的访问。</p>
<p><strong>访问一个网页的过程</strong>，协议：DNS、HTTP、TCP、OSPF、IP、ARP</p>
<p>1 浏览器向DNS请求url的服务器IP地址, 2) 域名系统DNS解析出IP地址 3) 浏览器与该服务器建立TCP连接 4) 通过HTTP获取内容</p>
<p><strong>DNS域名解析协议</strong>，简单描述其工作原理。</p>
<p>域名解析是把域名映射成IP地址或者把IP地址映射成域名的过程。</p>
<p>域名解析有两种方式：递归查询和迭代查询。 递归查询时，DNS请求客户身份有变化，迭代查询时，请求客户一直是本地主机。</p>
<h2 id="2-11-各种协议"><a href="#2-11-各种协议" class="headerlink" title="2.11 各种协议"></a>2.11 各种协议</h2><p><strong>ICMP协议</strong>： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 </p>
<p><strong>NAT协议</strong>：内网地址转换协议，是一种将私有（保留）地址转化为合法IP地址的转换技术。</p>
<p><strong>DHCP协议</strong>：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<hr>
<h1 id="第三章-算法与数据结构"><a href="#第三章-算法与数据结构" class="headerlink" title="第三章 算法与数据结构"></a>第三章 算法与数据结构</h1><h2 id="3-0-知识点汇总"><a href="#3-0-知识点汇总" class="headerlink" title="3.0 知识点汇总"></a>3.0 知识点汇总</h2><ol>
<li>链表与数组。</li>
<li>队列和栈，出栈与入栈。</li>
<li>链表的删除、插入、反向。</li>
<li>字符串操作。</li>
<li>Hash表的hash函数，冲突解决方法有哪些。</li>
<li>各种排序：冒泡、选择、插入、希尔、归并、快排、堆排、桶排、基数的原理、平均时间复杂度、最坏时间复杂度、空间复杂度、是否稳定。</li>
<li>快排的partition函数与归并的Merge函数。</li>
<li>对冒泡与快排的改进。</li>
<li>二分查找</li>
<li>二叉树、B+树、AVL树、红黑树、哈夫曼树。</li>
<li>二叉树的前中后续遍历：递归与非递归写法，层序遍历算法。</li>
<li>图的BFS与DFS算法，最小生成树prim算法与最短路径Dijkstra算法。</li>
<li>KMP算法。</li>
<li>排列组合问题。</li>
<li>动态规划、贪心算法、分治算法。</li>
<li>大数据处理：类似10亿条数据找出最大的1000个数………等等</li>
</ol>
<h2 id="3-1-排序算法"><a href="#3-1-排序算法" class="headerlink" title="3.1 排序算法"></a>3.1 排序算法</h2><h3 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1.直接插入排序"></a>1.直接插入排序</h3><p><strong>思想</strong>：每次将一个待排序的数据按照其关键字的大小插入到前面已经排序好的数据中的适当位置，直到全部数据排序完成。<strong>时间复杂度</strong>：O(n^2) O(n) O(n^2) （最坏 最好 平均） <strong>空间复杂度</strong>：O(1) <strong>稳定性</strong>： 稳定 每次都是在前面已排好序的序列中找到适当的位置，只有小的数字会往前插入，所以原来相同的两个数字在排序后相对位置不变。 <strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 插入排序</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; array.length; i++ ) &#123;</div><div class="line">        <span class="keyword">int</span> val = array[i];</div><div class="line">        <span class="keyword">int</span> j = i -<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; val) &#123;  <span class="comment">// array[j] &gt; val</span></div><div class="line">            array[j+<span class="number">1</span>] = array[j];</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        array[j+<span class="number">1</span>] = val; <span class="comment">//  array[j+1] 不是array[j]</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-希尔排序"><a href="#2-希尔排序" class="headerlink" title="2.希尔排序"></a>2.希尔排序</h3><p><strong>思想</strong>：希尔排序根据增量值对数据按下标进行分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整体采用直接插入排序得到有序数组，算法终止。 <strong>时间复杂度</strong>：O(n2) O(n) O(n1.5) （最坏，最好，平均） <strong>空间复杂度</strong>：O(1) <strong>稳定性</strong>：不稳定 因为是分组进行直接插入排序，原来相同的两个数字可能会被分到不同的组去，可能会使得后面的数字会排到前面，使得两个相同的数字排序前后位置发生变化。 <strong>不稳定举例</strong>: 4 3 3 2 按2为增量分组，则第二个3会跑到前面 </p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len;</div><div class="line">    len = array.length / <span class="number">2</span>; <span class="comment">// 分成n/2组</span></div><div class="line">    <span class="keyword">while</span> (len &gt;= <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &lt; array.length; ++i) &#123; <span class="comment">//对每组进行直接插入排序</span></div><div class="line">            <span class="keyword">int</span> temp = array[i];</div><div class="line">            <span class="keyword">int</span> j = i - len;</div><div class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp) &#123;</div><div class="line">                array[j + len] = array[j];</div><div class="line">                j -= len;</div><div class="line">            &#125;</div><div class="line">            array[j + len] = temp;</div><div class="line">        &#125;</div><div class="line">        len /= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>交换排序</strong></p>
<h3 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3.冒泡排序"></a>3.冒泡排序</h3><p><strong>思想</strong>：对待排序元素的关键字从后往前进行多遍扫描，遇到相邻两个关键字次序与排序规则不符时，就将这两个元素进行交换。这样关键字较小的那个元素就像一个泡泡一样，从最后面冒到最前面来。 <strong>时间复杂度</strong>：最坏：O(n2) 最好: O(n) 平均: O(n2) <strong>空间复杂度</strong>：O(1) <strong>稳定性</strong>：稳定，相邻的关键字两两比较，如果相等则不交换。所以排序前后的相等数字相对位置不变。 </p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> flag; <span class="comment">// 用来判断当前这一轮是否有交换数值,若没有则表示已经排好许了</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">        flag = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 这边要注意 for (int j = array.length -1; j &gt;= i + 1; j--)。 不要写成</span></div><div class="line"><span class="comment">         * for (int j =  i + 1; j &lt; array.length ; j++)</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = array.length -<span class="number">1</span>; j &gt;= i + <span class="number">1</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j -<span class="number">1</span> ] &gt; array[j]) &#123;</div><div class="line">                <span class="comment">//数据交换</span></div><div class="line">                <span class="keyword">int</span> temp = array[j - <span class="number">1</span>];</div><div class="line">                array[j - <span class="number">1</span>] = array[j];</div><div class="line">                array[j] = temp;</div><div class="line">                <span class="comment">//设置标志位</span></div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!flag) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><p><strong>思想</strong>：该算法是分治算法，首先选择一个基准元素,根据基准元素将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。基准元素的选择对快速排序的性能影响很大，所有一般会想打乱排序数组选择第一个元素或则随机地从后面选择一个元素替换第一个元素作为基准元素。 <strong>时间复杂度</strong>：最坏:O(n2) 最好: O(nlogn) 平均: O(nlogn) <strong>空间复杂度</strong>：O(nlogn)用于方法栈 <strong>稳定性</strong>：不稳定 快排会将大于等于基准元素的关键词放在基准元素右边，加入数组 1 2 2 3 4 5 选择第二个2 作为基准元素，那么排序后 第一个2跑到了后面，相对位置发生变化。 </p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    partition(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>选择排序</strong></p>
<h3 id="5-直接选择排序"><a href="#5-直接选择排序" class="headerlink" title="5.直接选择排序"></a>5.直接选择排序</h3><p><strong>思想</strong>：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后每次从剩余未排序元素中继续寻找最小（大）元素放到已排序序列的末尾。以此类推，直到所有元素均排序完毕 <strong>时间复杂度</strong>：最坏:O(n^2) 最好: O(n^2) 平均: O(n^2) <strong>空间复杂度</strong>：O(1) <strong>稳定性</strong>：不稳定 例如数组 2 2 1 3 第一次选择的时候把第一个2与1交换使得两个2的相对次序发生了改变。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> minIdx = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIdx]) &#123;</div><div class="line">                minIdx = j;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        exch(array, i, minIdx);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h3><p><strong>思想</strong>：堆排序是利用堆的性质进行的一种选择排序，先将排序元素构建一个最大堆,每次堆中取出最大的元素并调整堆。将该取出的最大元素放到已排好序的序列前面。这种方法相对选择排序，时间复杂度更低，效率更高。 <strong>时间复杂度</strong>：最坏:O(nlog2n) 最好: O(nlog2n) 平均: O(nlog2n) <strong>空间复杂度</strong>：O(1) <strong>稳定性</strong>：不稳定 例如 5 10 15 10。 如果堆顶5先输出，则第三层的10(最后一个10)的跑到堆顶，然后堆稳定，继续输出堆顶，则刚才那个10跑到前面了，所以两个10排序前后的次序发生改变。 </p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个元素没有利用</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> N = array.length -<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--) &#123; <span class="comment">// k &gt;= 1</span></div><div class="line">        sink(array, k, N);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// 最大堆, 选择最大值放在最后</span></div><div class="line">        exch(array, <span class="number">1</span>, N --);</div><div class="line">        sink(array, <span class="number">1</span>, N);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span></span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</div><div class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;</div><div class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; array[j] &lt; array[j+<span class="number">1</span>]) &#123; <span class="comment">// &lt;</span></div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (array[j] &lt; array[k]) <span class="keyword">break</span>;  <span class="comment">// &lt;</span></div><div class="line">        exch(array, k, j);</div><div class="line">        k = j;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7.归并排序"></a>7.归并排序</h3><p><strong>思想</strong>：归并排序采用了分治算法，首先递归将原始数组划分为若干子数组，对每个子数组进行排序。然后将排好序的子数组递归合并成一个有序的数组。 <strong>时间复杂度</strong>：最坏:O(nlog2n) 最好: O(nlog2n) 平均: O(nlog2n) <strong>空间复杂度</strong>：O(n) <strong>稳定性</strong>：稳定 </p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</div><div class="line">        <span class="keyword">int</span> middle = (left + right) &gt;&gt; <span class="number">1</span>;</div><div class="line">        <span class="comment">//递归处理相关的合并事项</span></div><div class="line">        sort(array, left, middle);</div><div class="line">        sort(array, middle + <span class="number">1</span>, right);</div><div class="line">        merge(array, left, middle, right);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</div><div class="line">    <span class="comment">//创建一个临时数组用来存储合并后的数据</span></div><div class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</div><div class="line">    <span class="keyword">int</span> left = lo;</div><div class="line">    <span class="keyword">int</span> right = mid + <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> k = lo;</div><div class="line">    <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= hi) &#123;</div><div class="line">        <span class="keyword">if</span> (array[left] &lt; array[right])</div><div class="line">            temp[k++] = array[left++];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            temp[k++] = array[right++];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//处理剩余未合并的部分</span></div><div class="line">    <span class="keyword">while</span> (left &lt;= mid)  temp[k++] = array[left++];</div><div class="line">    <span class="keyword">while</span> (right &lt;= hi)  temp[k++] = array[right++];</div><div class="line">    <span class="comment">//将临时数组中的内容存储到原数组中</span></div><div class="line">    <span class="keyword">while</span> (lo &lt;= hi) array[lo] = temp[lo++];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2-查找"><a href="#3-2-查找" class="headerlink" title="3.2 查找"></a>3.2 查找</h2><h3 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1. 顺序查找"></a>1. 顺序查找</h3><p><strong>思路</strong>：这是最简单的算法，从头开始遍历每个元素，并将每个元素与查找元素比较，如果一致则返回。 <strong>时间复杂度</strong>: O(N) <strong>空间复杂度</strong>: O(1) </p>
<p><strong>代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (array[i] == num) &#123;</div><div class="line">            <span class="keyword">return</span> i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2. 二分查找"></a>2. 二分查找</h3><p><strong>思路</strong>：二分查找前提是查找的数组是有序的，利用数据有序的特性提高查找性能。首先与数组中间位置的值比较，如果查找值大于中间位置值，则对数组右边以相同的思路查找，否则在左边以相同方式查找。这种方式使得每次查找范围变为原来的1/2. <strong>时间复杂度</strong>: O(log2n) <strong>空间复杂度</strong>: O(1)</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">halfSearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = array.length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</div><div class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span> (array[mid] == num) &#123;</div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; num) &#123;</div><div class="line">            hi = mid -<span class="number">1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            lo = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-hash-算法"><a href="#3-hash-算法" class="headerlink" title="3. hash 算法"></a>3. hash 算法</h3><p><strong>思想</strong>：哈希表是根据设定的<strong>哈希函数H(key)</strong>和<strong>处理冲突方法</strong>将一组关键字映射到一个有限的地址区间上，并将关键字对应的值存储在该地址空间，可以通过关键字快速获取对应的值，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。作为线性数据结构与表格和队列等相比，哈希表无疑是查找速度比较快的一种。 <strong>查找复杂度:</strong> O(1) </p>
<p><strong>哈希函数寻址</strong>：</p>
<ol>
<li><strong>直接寻址法</strong>：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a?key + b，其中a和b为常数（这种散列函数叫做自身函数）</li>
<li><strong>数字分析法</strong>：因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。</li>
<li><strong>平方取中法</strong>：取关键字平方后的中间几位作为散列地址</li>
<li><strong>折叠法</strong>：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。</li>
<li><strong>除留余数法</strong>：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p&lt;=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。</li>
</ol>
<p><strong>hash冲突及解决</strong> ：</p>
<p>hash冲突在所难免，解决冲突是一个复杂问题。冲突主要取决于： （1）与散列函数有关，一个好的散列函数的值应尽可能平均分布。 （2）与解决冲突的哈希冲突函数有关。 （3）与负载因子的大小。太大不一定就好，而且浪费空间严重，负载因子和散列函数是联动的。 解决冲突的办法： （1）<strong>开放定址法</strong>：线性探查法、平方探查法、伪随机序列法、双哈希函数法。 （2) <strong>链地址法</strong>：把所有同义词，即hash值相同的记录，用单链表连接起来。</p>
<p><strong>应用：</strong> 1.字符串哈希 2.加密哈希 3.几何哈希 4.布隆过滤器</p>
<p><strong>不足：</strong>获取有序序列复杂度高</p>
<h3 id="4-二叉树搜索树"><a href="#4-二叉树搜索树" class="headerlink" title="4. 二叉树搜索树"></a>4. 二叉树搜索树</h3><p><strong>思想</strong> ：</p>
<p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 1.若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 2.若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 3.任意节点的左、右子树也分别为二叉查找树。 4.没有键值相等的节点（no duplicate nodes）。 复杂度: 插入和查找的时间复杂度均为O(logN), 最坏为O(N)</p>
<p><strong>插入</strong> :</p>
<ol>
<li><p>如果当前结点是null，则创建新结点返回。</p>
</li>
<li><p>如果插入结点比当前结点值大，则插入其右孩子结点中。</p>
</li>
<li><p>如果插入结点比当前结点值小，则插入其左孩子结点中。 <strong>复杂度</strong>: 平均 O(logn) 最坏O(n) <strong>代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Tree <span class="title">insert</span><span class="params">(Tree root, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tree(val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (val == root.val) &#123;</div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root.val) &#123;</div><div class="line">        root.right = insert(root.right, val);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        root.left = insert(root.left, val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>查找</strong> :</p>
<p>类似于二分查找，小于当前值，则去左子树查找，大于当前节点值，则去右子树查找。 <strong>时间复杂度</strong>: 平均O(logn) 最坏O(n)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Tree <span class="title">search</span><span class="params">(Tree root, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</div><div class="line">     	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"> 	&#125;</div><div class="line"> 	<span class="keyword">if</span>(root.val == val) &#123;</div><div class="line">    	<span class="keyword">return</span> root;</div><div class="line"> 	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; val) &#123;</div><div class="line">     	<span class="keyword">return</span> search(root.left, val);</div><div class="line"> 	&#125; <span class="keyword">else</span> &#123;</div><div class="line">    	<span class="keyword">return</span> search(root.right, val);</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>查找最小值、最大值</strong> ：</p>
<p>根据二叉搜索树的特点，最小结点都是在最左结点上，或无左子树的根节点。最大值为最右节点或根。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Tree <span class="title">min</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> min(root.left);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Tree <span class="title">max</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> max(root.right);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>删除</strong> ：</p>
<ol>
<li><p>删除最小结点</p>
<p>找到根结点最左结点，如果其不存在右孩子则直接删除，否则用右孩子替换最左结点。需要考虑根结点为null和根为最小值的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Tree <span class="title">deleteMin</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</div><div class="line">        root.left = deleteMin(root.left);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> root.right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>删除最大结点</p>
<p>找到最右孩子结点，其存在左结点的话就用左结点替换否则直接删除.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Tree <span class="title">deleteMax</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</div><div class="line">        root.right = deleteMax(root.right);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> root.left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>删除某个结点</p>
<p>首先通过查找方法找到该节点，然后删除策略：</p>
<ul>
<li><p>如果该节点无左右子树，直接删除</p>
</li>
<li><p>如果只存在一个子树，用孩子结点替换该节点。</p>
</li>
<li><p>如果存在两个子树，那么可以用左子树中最大的结点或右子树中最小结点替换，并删除子树中的节点.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> Tree <span class="title">delete</span><span class="params">(Tree root, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root.val == val) &#123;</div><div class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.left!= <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</div><div class="line">            Tree leftBig = max(root.left);</div><div class="line">            root.val = leftBig.val;</div><div class="line">            root.left = delete(root.left, leftBig.val);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">return</span> root.left;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> root.right;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val) &#123;</div><div class="line">        root.right = delete(root.right, val);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        root.left = delete(root.left, val);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="5-AVL查找树"><a href="#5-AVL查找树" class="headerlink" title="5. AVL查找树"></a>5. AVL查找树</h3><p>6.1 思想</p>
<p>二叉树查找树在插入时没有对二叉树的深度和结构做一个调整，使得叶子结点深度不一，在查找时深度越深的结点时间复杂度越高。为了改进查找的时间时间复杂度，于是出现了平衡二叉树(AVL).<strong>平衡二叉树使得每个结点的左结点和右结点的深度差不超过1.</strong></p>
<p>6.2 查找</p>
<p>查找与二叉查找树一样。</p>
<p>6.3 插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当在AVL中插入新的结点时，需要根据实际情况对AVL中的某些结点做单旋转或双旋转操作，单旋转表示做一次顺时针或逆时针的旋转操作，而双旋转则做两次单旋转操作（先顺时针后逆时针，或者先逆时针后顺时针），单旋转发生在LL型插入和RR型插入，而双旋转则发生在LR型插入和RL型插入。以下的失去平衡点都指的是离插入点最近的那个失去平衡的结点。</div></pre></td></tr></table></figure>
<p>LL型：插入点位于失去平衡点的左孩子的左子树上； RR型：插入点位于失去平衡点的右孩子的右子树上； LR型：插入点位于失去平衡点的左孩子的右子树上； RR型：插入点位于失去平衡点的右孩子的左子树上。</p>
<p><strong>插入思路</strong> 和二叉搜索树的插入一样，首先在树中找到对应的位置然后插入，接着自底向上向根节点折回，于在插入期间成为不平衡的所有节点上进行旋转来完成。因为折回到根节点的路途上最多有 1.5 乘 log n 个节点，而每次AVL 旋转都耗费恒定的时间，插入处理在整体上耗费 O(log n) 时间。　 具体插入过程如下:</p>
<ol>
<li>如果当前结点为空，创建新结点返回.</li>
<li>如果当前结点值和插入值相同，不做处理返回。</li>
<li>如果插入值大于当前结点则插入到右其右孩子结点中。插入完成后比较左右孩子结点进行判断树是否失去平衡。如果是判断属于那种类型(RR, RL),并响应的旋转。最后更新当前结点的深度(孩子结点的最大深度加1，默认null深度为-1)。</li>
<li>否则插入到其做孩子上。 同样比较左右孩子的深度判断是否平衡，对于失去平衡的情况下做出调整。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">private AvlNode&lt;AnyType&gt; insert(AnyType x, AvlNode&lt;AnyType&gt; t) &#123;</div><div class="line">    if (t == null)</div><div class="line">        return new AvlNode&lt;AnyType&gt;(x, null, null);</div><div class="line">    int compareResult = myCompare(x, t.element);</div><div class="line">    if (compareResult &lt; 0) &#123;</div><div class="line">        t.left = insert(x, t.left);</div><div class="line">        if (height(t.left) - height(t.right) == 2) &#123;</div><div class="line">            if (myCompare(x, t.left.element) &lt; 0)     //左左情况</div><div class="line">                t = rotateWithLeftChild(t);</div><div class="line">            else                                    //左右情况</div><div class="line">                t = doubleWithLeftChild(t);</div><div class="line">        &#125;</div><div class="line">    &#125; else if (compareResult &gt; 0) &#123;</div><div class="line">        t.right = insert(x, t.right);</div><div class="line">        if (height(t.right) - height(t.left) == 2) &#123;</div><div class="line">            if (myCompare(x, t.right.element) &lt; 0)        //右左情况</div><div class="line">                t = doubleWithRightChild(t);</div><div class="line">            else                                        //右右情况</div><div class="line">                t = rotateWithRightChild(t);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //完了之后更新height值</div><div class="line">    t.height = Math.max(height(t.left), height(t.right)) + 1;</div><div class="line">    return t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>6.4 删除</p>
<p>从AVL树中删除可以通过把要删除的节点向下旋转成一个叶子节点，接着直接剪除这个叶子节点来完成。因为在旋转成叶子节点期间最多有 log n个节点被旋转，而每次 AVL 旋转耗费恒定的时间，删除处理在整体上耗费 O(log n) 时间。 a.当被删除节点n是叶子节点，直接删除 b.当被删除节点n只有一个孩子，删除n，用孩子替代该节点的位置 c.当被删除结点n存在左右孩子时，真正的删除点应该是n的中序遍在前驱，或者说是左子树最大的节点，之后n的值替换为真正删除点的值。这就把c归结为a，b的问题。</p>
<p>从删除的结点处自低向上向根结点折回，根据当前结点的左右孩子深度判断是否平衡，如果不平衡则按选择规则进行旋转。最后更新当前结点深度，如此递归折回到根结点。</p>
<h3 id="6-B-树（B树）"><a href="#6-B-树（B树）" class="headerlink" title="6. B-树（B树）"></a>6. B-树（B树）</h3><p>7.1 定义</p>
<p>B-树是一种平衡的多路查找树，它在文件系统中很有用。 定义：一棵m 阶的B-树，或者为空树，或为满足下列特性的m 叉树： ⑴树中每个结点至多有m 棵子树； ⑵若根结点不是叶子结点，则至少有两棵子树； ⑶除根结点之外的所有非终端结点至少有⎡m/2⎤ 棵子树； ⑷所有的非终端结点中包含以下信息数据：（n，A0，K1，A1，K2，…，Kn，An） 其中：Ki（i=1,2,…,n）为关键码，且Ki&lt; Ki+1，Ai 为指向子树根结点的指针(i=0,1,…,n)，且指针Ai-1 所指子树中所有结点的关键码均小于Ki (i=1,2,…,n)，An 所指子树中所有结点的关键码均大于Kn， ⎡m/2⎤ −1 ≤ n ≤m −1 ，n 为关键码的个数。 ⑸所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空</p>
<p>7.2 查找</p>
<p>B-树的查找是由两个基本操作交叉进行的过程，即 ⑴在B-树上找结点； ⑵在结点中找关键码。 由于，通常B-树是存储在外存上的，操作⑴就是通过指针在磁盘相对定位，将结点信息读入内存，之后，再对结点中的关键码有序表进行顺序查找或折半查找。因为，在磁盘上读取结点信息比在内存中进行关键码查找耗时多，每次向下搜索一层都需要从内存中加载磁盘信息，B-树的层次树是决定B-树查找效率的首要因素。</p>
<p>7.2 插入</p>
<p>1.插入 在B-树上插入关键码与在二叉排序树上插入结点不同，关键码的插入不是在叶结点上 进行的，而是在最底层的某个非终端结点中添加一个关键码，若该结点上关键码个数不超过m-1 个，则可直接插入到该结点上；否则，该结点上关键码个数至少达到m 个，因而使该结点的子树超过了m棵，这与B-树定义不符。所以要进行调整，即结点的“分裂”。方法为：关键码加入结点后，将结点中的关键码分成三部分，使得前后两部分关键码个数个结点将其插入到父结点中。若插入父结点而使父结点中关键码个数超过m-1，则父结点继续分裂，直到插入某个父结点，其关键码个数小于m。可见，B-树是从底向上生长的。</p>
<p>7.3 删除</p>
<p>分两种情况： (1)删除最底层结点中关键码 a)若结点中关键码个数大于⎡m / 2⎤ -1，直接删去。 b)否则除余项与左兄弟(无左兄弟，则找左兄弟)项数之和大于等于2( -1) 就与它 们父结点中的有关项一起重新分配 (2)删除为非底层结点中关键码 若所删除关键码非底层结点中的Ki，则可以指针Ai 所指子树中的最小关键码X 替代 Ki，然后，再删除关键码X，直到这个X 在最底层结点上，即转为(1)的情形</p>
<p>7.2 B-树的特性：</p>
<p>1.关键字集合分布在整颗树中； 2.任何一个关键字出现且只出现在一个结点中； 3.搜索有可能在非叶子结点结束； 4.其搜索性能等价于在关键字全集内做一次二分查找； 5.自动层次控制；</p>
<p><a href="http://c.biancheng.net/cpp/html/1028.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/1028.html</a></p>
<h3 id="7-B-树"><a href="#7-B-树" class="headerlink" title="7. B+树"></a>7. B+树</h3><p>8.1 定义</p>
<p>⑴有n 棵子树的结点中含有n 个关键码； ⑵所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且 叶子结点本身依关键码的大小自小而大的顺序链接。 ⑶所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键码。</p>
<p>8.2 B+的特性</p>
<p>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 2.不可能在非叶子结点命中； 3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 4.更适合文件索引系统；</p>
<p>8.3 操作</p>
<p>1)查找操作 对B+树可以进行两种查找运算： a.从最小关键字起顺序查找； b.从根结点开始，进行随机查找。 在查找时，若非终端结点上的剧组机等于给定值，并不终止，而是继续向下直到叶子结点。因此，在B+树中，不管查找成功与否，每次查找都是走了一条从根到叶子结点的路径。其余同B-树的查找类似。 2).插入操作 B+树的插入与B树的插入过程类似。不同的是B+树在叶结点上进行，如果叶结点中的关键码个数超过m，就必须分裂成关键码数目大致相同的两个结点，并保证上层结点中有这两个结点的最大关键码。(算法见百度百科) 3)删除操作 B+树的删除也仅在叶子结点进行，当叶子结点中的最大关键字被删除时，其在非终端结点中的值可以作为一个“分界关键字”存在。若因删除而使结点中关键字的个数少于m/2 （m/2结果取上界，如5/2结果为3）时，其和兄弟结点的合并过程亦和B-树类似。</p>
<p> B+树和B-树最大的不同点：</p>
<p>1).B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。</p>
<p>2).在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历(例如查看一个目录下的所有文件，一个表中的所有记录等)，这也是很多数据库和文件系统使用B+树的缘故。 3）B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因<a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/25/2608880.html" target="_blank" rel="external">http://www.cnblogs.com/biyeymyhjob/archive/2012/07/25/2608880.html</a><a href="http://blog.csdn.net/v_JULY_v/article/details/6530142/" target="_blank" rel="external">http://blog.csdn.net/v_JULY_v/article/details/6530142/</a></p>
<h3 id="8-红黑树"><a href="#8-红黑树" class="headerlink" title="8 . 红黑树"></a>8 . 红黑树</h3><p>思想</p>
<p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。</p>
<p>特性</p>
<p>性质1. 节点是红色或黑色。 性质2. 根是黑色。 性质3. 所有叶子都是黑色（叶子是NIL节点）。 性质4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 性质5. 从任一节点到其每个叶子的所有简单路径 都包含相同数目的黑色节点。</p>
<p>插入</p>
<p>II、红黑树插入的几种情况： 情况1，z的叔叔y是红色的。 情况2：z的叔叔y是黑色的，且z是右孩子 情况3：z的叔叔y是黑色的，且z是左孩子</p>
<p>删除</p>
<p>III、红黑树删除的几种情况。 情况1：x的兄弟w是红色的。 情况2：x的兄弟w是黑色的，且w的俩个孩子都是黑色的。 情况3：x的兄弟w是黑色的，且w的左孩子是红色，w的右孩子是黑色。 情况4：x的兄弟w是黑色的，且w的右孩子是红色的。</p>
<p><a href="http://www.cnblogs.com/daoluanxiaozi/p/3340382.html" target="_blank" rel="external">http://www.cnblogs.com/daoluanxiaozi/p/3340382.html</a></p>
<p>红黑树和AVL树的比较：</p>
<p>红黑树： (1)并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。 (2)此外，由于它的设计，任何不平衡都会在三次旋转之内解决。红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。 AVL树： (1)它的左子树和右子树都是AVL树，左子树和右子树的高度差不能超过; (2) 查找、插入和删除在平均和最坏情况下都是O(log n),增加和删除可能需要通过一次或多次树旋转来重新平衡这个树; (3)一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1) 一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)). 一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)).</p>
<h3 id="9-哈夫曼树"><a href="#9-哈夫曼树" class="headerlink" title="9.  哈夫曼树"></a>9.  哈夫曼树</h3><h2 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>键索引计数法：</p>
<ul>
<li>频率统计：使用int数组count[]计算每个建出现的频率</li>
<li>将频率转化为索引：使用count来计算每个键在排序结果中的起始索引位置</li>
<li>数据分类：将所有元素转移到一个辅助数组aux中以进行排序。</li>
<li>回写：将元素排序后的结果复制回原数组。</li>
</ul>
</blockquote>
<p>低优先字符排序</p>
<p><strong>思路</strong>：从右到左以每个位置的字符为键，用键索引计数法将字符串排序W遍（字符串长度） <strong>复杂度</strong>: O(NW) W为字符串长度，N为元素选择空间 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public static void sort(String[] a, int w) &#123;</div><div class="line">    // 通过前w个字符将a[] 排序</div><div class="line">    int N = a.length;</div><div class="line">    int R = 256;</div><div class="line">    String[] aux = new String[N];</div><div class="line">    for (int d = w - 1; d &gt;= 0; d--) &#123;</div><div class="line">        int[] count = new int[R + 1];</div><div class="line">        // 计算出频率</div><div class="line">        for (int i = 0; i &lt; N; i++) &#123;</div><div class="line">            count[a[i].charAt(d) + 1]++;</div><div class="line">        &#125;</div><div class="line">        // 将频率转换为索引</div><div class="line">        for (int r = 0; r &lt; R; r++) &#123;</div><div class="line">            count[r + 1] += count[r];</div><div class="line">        &#125;</div><div class="line">        // 将元素分类</div><div class="line">        for (int i = 0; i &lt; N; i++ ) &#123;</div><div class="line">            aux[count[a[i].charAt(d)] ++] =  a[i];</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; N; i ++ ) &#123;</div><div class="line">            a[i] = aux[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>高位优先字符串排序</p>
<p><strong>思路</strong>：解决字符串长度不一致的情况，采用从左到右的次序进行排序。 在高位优先排序时需要注意的字符串末尾的情况，因为字符串长度不一，合理的做法是将所有字符都已被检查的字符串所在的子数组排在所有子数组的前面，这样不需要对这些检查完成的字符串再次递归排序，也避免了IndexOutOfBound。 高位优先排序在已排号序的位置，根据字符进行分组，将数组分为更小的数组进行排序，利用了分治算法提高了算法的性能。 <strong>复杂度</strong>:O(N) 到O(Nw)之间 实现：</p>
<p><strong>三向字符串快速排序</strong> <strong>思路</strong>:结合了快速排序和高位优先字符串排序算法，采用高位优先字符串排序算法的思路，根据字符串从左到右的字符对字符串进行排序。排序时使用快速排序的思想，使用首字符进行三向切分为首字母小余、等于，大于切分字符的字符串数组，然后递归地将得到的三个字数组排序： <strong>优势</strong>：高位优先字符串排序算法会产生大量的子数组，而三向字符串快速排序切分总只有三个。因此该算法能够很好处理等值键、有较长公告前缀的键、取值范围娇小的键和小数组。 相对于高位优先字符串排序需要的空间更少。 复杂度： <strong>实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public static void sort(String[] strArr) &#123;</div><div class="line">    sort(strArr, 0, strArr.length - 1, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 对字符串串数组strArr的 strArr[lo]到strArr[hi]的字符串根据d为的字符进行排序</div><div class="line"> * @param strArr</div><div class="line"> * @param lo</div><div class="line"> * @param hi</div><div class="line"> * @param d</div><div class="line"> */</div><div class="line">private static void sort(String[] strArr, int lo, int hi , int d) &#123;</div><div class="line">    if (hi &lt;= lo) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    int lt = lo, gt = hi;</div><div class="line">    int val = strArr[lo].charAt(d);</div><div class="line">    int i = lo + 1;</div><div class="line">    while(i &lt;= gt) &#123;</div><div class="line">        int tmp = strArr[i].charAt(d);</div><div class="line">        if ( tmp &lt; val) &#123;</div><div class="line">            exch(strArr, lt++, i++);</div><div class="line">        &#125; else if( tmp &gt; val) &#123;</div><div class="line">            exch(strArr, i, gt--);</div><div class="line">        &#125; else &#123;</div><div class="line">            i ++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    sort(strArr, lo, lt-1, d);</div><div class="line">    if (val &gt;= 0 )  &#123;</div><div class="line">        sort(strArr, lt, gt, d+1);</div><div class="line">    &#125;</div><div class="line">    sort(strArr, gt+1, hi, d);</div><div class="line">&#125;</div><div class="line">private static void exch(String[] a, int i ,int j) &#123;</div><div class="line">    String tmp = a[i];</div><div class="line">    a[i] = a[j];</div><div class="line">    a[j] = tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：和快速排序一样，最好在排序之前将数组打乱或将第一个元素和一个随机位置的元素交换以得到一个随机的切分元素，避免快速排序算法接近最坏情况</p>
</blockquote>
<p>总结：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>原地排序</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>优势领域</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符串的插入排序</td>
<td>是</td>
<td>是</td>
<td>N到N2之间</td>
<td>1</td>
<td>小数组或已经有序的数组</td>
</tr>
<tr>
<td>快速排序</td>
<td>否</td>
<td>是</td>
<td>N(log2N)</td>
<td>logN</td>
<td>通用排序算法，特别适合空间不足的情况</td>
</tr>
<tr>
<td>归并排序</td>
<td>是</td>
<td>否</td>
<td>N(log2N)</td>
<td>N</td>
<td>稳定的通用排序算法</td>
</tr>
<tr>
<td>三向快速排序</td>
<td>否</td>
<td>是</td>
<td>N到NlogN之间</td>
<td>logN</td>
<td>大量重复建</td>
</tr>
<tr>
<td>低位优先的字符串排序</td>
<td>是</td>
<td>否</td>
<td>NW</td>
<td>N</td>
<td>较长的定长字符串</td>
</tr>
<tr>
<td>高位优先的字符串排序</td>
<td>是</td>
<td>否</td>
<td>N到Nw之间</td>
<td>N+WR</td>
<td>随机字符串</td>
</tr>
<tr>
<td>三向字符串快速排序</td>
<td>否</td>
<td>是</td>
<td>N到Nw之间</td>
<td>W+logN</td>
<td>通用排序算法，特别适合用于含有较长公共前缀的字符串</td>
</tr>
</tbody>
</table>
<h3 id="查找树"><a href="#查找树" class="headerlink" title="查找树"></a>查找树</h3><ul>
<li><p>单词查找树（trie）</p>
<p>基本性质： 是由连接结点组成的数据结构，除了根结点，每个结点有且只有一条从父结点指向它的链接。每条链接都对应着一个字符，也可以用链接所对应的字符标记被指向的结点。值为空的结点在符号表中没有对应的键，它们的存在是为了简化单词查找树的查找操作。 查找过程：从根结点开始，首先经过的键是首字母所对应的链接。在下一个结点中沿着第二个字符所对应的链接继续前进。依此类推，直到键的最后一个字符所指向的结点或者遇到一条空链接。此时有三种情况：</p>
<ul>
<li><p>键的尾字符所对应的结点中的值非空，这是一次命中查找，则返回尾字符所对应的结点中保存的值。</p>
</li>
<li><p>键的尾字符所对应的结点中的值为空，表示未命中。</p>
</li>
<li><p>查找结束于一条空链接，表示未命中。</p>
<p>插入过程：进行插入的时候和二叉查找树一样，需要先进行查找，会遇到以下两个情况：</p>
</li>
<li><p>到达键尾部之前就遇到空链接，则创建对应的结点并将键值保存到最后一个字符的结点中。</p>
</li>
<li><p>在遇到空链接之前就到达了键的尾字符，在这种情况下，和关联性数组一样，将该结点的值设置为键所对应的值。</p>
<p>删除过程：首先找到对应的结点并将它的值设置为空，如果该结点含有一个非空的链接指向某个子结点那么就不需要进行其他操作。如果它所有链接均为空，那么就需要从数据结构中删去这个结点，如果删去它使得它的父节点的所有链接也均为空，就需要继续删除它的父结点，依此类推。 性质：</p>
</li>
<li><p>单词查找树的链表结构和键的插入或删除顺序无关：对于给定任意一组键，其单词查找树都是唯一的。</p>
</li>
<li><p>在单词查找树中查找一个键或插入一个键时，访问数组的次数最多的键的长度加1.</p>
</li>
<li><p>未命中查找平均所需检查的结点的数量为 logRN</p>
</li>
<li><p>一棵单词查找树的链接总数在RN到RNw之间，其中w为建的平均长度。 ？？？</p>
<p>应用：</p>
</li>
<li><p>数字帐号</p>
</li>
<li><p>URL</p>
</li>
<li><p>文本处理</p>
</li>
<li><p>基因组数据中的蛋白质</p>
<p>代码实现：</p>
</li>
</ul>
</li>
<li><p>三向单词查找树</p>
<p>思想：为了避免R向单词查找树过度的浪费空间，三向单词查找树每个结点都含有一个字符、三条链接和一个值。这三条链接分别对应着当前字母小于、等于和大于结点字母的所有键。 查找：查找时比较键的首字母和根结点的字母，如果键的首字母较小，就选择左链接。如果较大，就选择右链接；如果相等，则选择中链接。然后递归的使用相同的算法，如果遇到一个空链接或则当前键结束时结点的值为空，那么查找未命中;如果键结束时结点的值非空则查找命中。 优势：节省大量空间。 性质：</p>
<ul>
<li><p>每个结点只有三个链接，链接总数在3N到3Nw之间</p>
</li>
<li><p>平均查找时间复杂度为lnN 次</p>
<p>代码实现：</p>
</li>
</ul>
</li>
</ul>
<h3 id="子字符串查找"><a href="#子字符串查找" class="headerlink" title="子字符串查找"></a>子字符串查找</h3><ul>
<li><p>暴力字符串查找算法</p>
</li>
<li><p>KMP算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">思想：KMP算法的想法是，设法利用这个已知信息，不要把&quot;搜索位置&quot;移回已经比较过的位置，只要继续把它向后移和移动匹配词就可以，这样就提高了效率。可以针对搜索词，算出一张部分匹配表。通过查表查到最后一个匹配字符对应的部分匹配值，并利用以下公式计算匹配词向后移动的位数：</div><div class="line">    移动位数 = 已匹配的字符数 - 对应的部分匹配值</div><div class="line"></div><div class="line">&quot;部分匹配值&quot;就是&quot;前缀&quot;和&quot;后缀&quot;的最长的共有元素的长度。以&quot;ABCDABD&quot;为例，</div></pre></td></tr></table></figure>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
</li>
</ul>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 计算部分匹配表</div><div class="line"> *</div><div class="line"> * @param pattern</div><div class="line"> * @param next</div><div class="line"> */</div><div class="line">public void makeNext(char[] pattern, int next[]) &#123;</div><div class="line">    int pIdx, maxSuffixLen; // pIdx:模版字符串下标；maxSuffixLen:最大前后缀长度</div><div class="line">    int m = pattern.length;  // 模版字符串长度</div><div class="line">    next[0] = 0; //模版字符串的第一个字符的最大前后缀长度为0</div><div class="line">    for (pIdx = 1, maxSuffixLen = 0; pIdx &lt; m; ++pIdx) //for循环，从第二个字符开始，依次计算每一个字符对应的next值</div><div class="line">    &#123;</div><div class="line">        /**</div><div class="line">         * maxSuffixLen 大于0 表示前一个字符已经存在匹配</div><div class="line">         */</div><div class="line">        while (maxSuffixLen &gt; 0 &amp;&amp; pattern[pIdx] != pattern[maxSuffixLen]) &#123; //递归的求出P[0]···P[q]的最大的相同的前后缀长度k</div><div class="line">            maxSuffixLen = next[maxSuffixLen - 1];          //不理解没关系看下面的分析，这个while循环是整段代码的精髓所在，确实不好理解</div><div class="line">        &#125;</div><div class="line">        if (pattern[pIdx] == pattern[maxSuffixLen]) //如果相等，那么最大相同前后缀长度加1</div><div class="line">        &#123;</div><div class="line">            maxSuffixLen++;</div><div class="line">        &#125;</div><div class="line">        next[pIdx] = maxSuffixLen;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public int kmp(String str, String pattern) &#123;</div><div class="line">    int[] next = new int[str.length()];</div><div class="line">    int strIdx, pIdx;</div><div class="line">    makeNext(pattern.toCharArray(), next);</div><div class="line"></div><div class="line">    for (strIdx = 0, pIdx = 0; strIdx &lt; str.length(); ++strIdx) &#123;</div><div class="line">        while (pIdx &gt; 0 &amp;&amp; pattern.charAt(pIdx) != str.charAt(strIdx)) &#123;</div><div class="line">            /**</div><div class="line">             * 移动匹配字符串位置</div><div class="line">             */</div><div class="line">            pIdx = next[pIdx - 1];</div><div class="line">        &#125;</div><div class="line">        if (pattern.charAt(pIdx) == str.charAt(strIdx)) &#123;</div><div class="line">            pIdx++;</div><div class="line">        &#125;</div><div class="line">        if (pIdx == pattern.length()) &#123;</div><div class="line">            return strIdx - pattern.length() + 1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>复杂度：时间复杂度最坏（3N） 空间复杂度 O(M）</p>
<h2 id="3-4-图"><a href="#3-4-图" class="headerlink" title="3.4 图"></a>3.4 图</h2><h2 id="3-5剑指offer"><a href="#3-5剑指offer" class="headerlink" title="3.5剑指offer"></a>3.5剑指offer</h2><p>01-二维数组中的查找</p>
<blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>思路</p>
<p>坑：不要从中间去，采用二分查找。如果中间查找会有两个区域需要查找，增加复杂度。 真确思路：<strong>从右上角开始遍历</strong>，有三种情况:</p>
<ol>
<li>如果相等，则直接返回。</li>
<li>如果值大于目标值，列减小。(因为从坐到右增大，因此右边的值不可能存在目标值)</li>
<li>如果值小于目标值，增大行。（从上往下增大，该值在最右上角为当前行最大，因此当前行没有更大的，可以往下一行找）</li>
</ol>
<p>思考，是否可以从左上角开始、右下角、左下角开始？ 左上角不可以，右下角不可以。因为这这两个移动后还是会形成两个区域需要查找。 左下角可以。</p>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public boolean Find(int [][] array,int target) &#123;</div><div class="line">    if (array == null || array[0].length == 0 ) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    int row = 0;</div><div class="line">    int col = array.length - 1;</div><div class="line">    while ( row &lt; array.length &amp;&amp; col &gt;=0 ) &#123;</div><div class="line">        if ( target &gt; array[row][col]) &#123;</div><div class="line">            row ++;</div><div class="line">        &#125; else if (target &lt; array[row][col]) &#123;</div><div class="line">            col --;</div><div class="line">        &#125; else &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>02-替换空格</p>
<blockquote>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>思路</p>
<ol>
<li>先计算空格数目</li>
<li>计算新的字符串长度，并构建新字符数组</li>
<li>逐个遍历和copy, 遇到空格用户“%20”替换</li>
</ol>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public String replaceSpace(StringBuffer str) &#123;</div><div class="line">    // 第一件重要的事</div><div class="line">    if( str == null || str.length() == 0)</div><div class="line">        return str.toString();</div><div class="line">    // 长度计算</div><div class="line">    int newlength = newLength(str);</div><div class="line">    char[] newChar = new char[newlength];</div><div class="line">    int idx = 0;</div><div class="line">    for (int i = 0; i &lt; str.length(); i++) &#123;</div><div class="line">        if (str.charAt(i) == &apos; &apos;) &#123;</div><div class="line">            newChar[idx++] = &apos;%&apos;;</div><div class="line">            newChar[idx++] = &apos;2&apos;;</div><div class="line">            newChar[idx++] = &apos;0&apos;;</div><div class="line">        &#125; else &#123;</div><div class="line">            newChar[idx++] = str.charAt(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return new String(newChar);</div><div class="line">&#125;</div><div class="line">private int newLength(StringBuffer str) &#123;</div><div class="line">    int spaceNum = 0; </div><div class="line">    for (int i = 0; i &lt; str.length(); i ++) &#123;</div><div class="line">        if (str.charAt(i) == &apos; &apos;) &#123;</div><div class="line">            spaceNum++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 或者  str.length() + spaceNum * 2</div><div class="line">    return (str.length() - spaceNum) + spaceNum * 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>03-从尾到头打印链表</p>
<blockquote>
<p>输入一个链表，从尾到头打印链表每个节点的值。</p>
</blockquote>
<p>思路</p>
<p>利用栈，先进后出的思路。</p>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</div><div class="line">    ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</div><div class="line">    if (null == listNode) &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;();</div><div class="line">    ListNode next = listNode;</div><div class="line">    while(null != next) &#123;</div><div class="line">        stack.push(next);</div><div class="line">        next = next.next;</div><div class="line">    &#125;</div><div class="line">    while(!stack.isEmpty()) &#123;</div><div class="line">        result.add(stack.pop().val);</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>04-旋转数组的最小数字</p>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
</blockquote>
<p>思路</p>
<p>二分查找，不断缩短查找范围。</p>
<ol>
<li>mid值与左右两端比较，如果小于右边，high=mid.</li>
<li>mid大于左边，low=mid</li>
<li>如果左值=mid值=右值，顺序遍历</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public int minNumberInRotateArray(int [] array) &#123;</div><div class="line">    if ( array == null || array.length == 0 ) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    int low = 0, high = array.length - 1;</div><div class="line">    int mid;</div><div class="line">    while ( low &lt; high &amp;&amp; array[low] &gt;= array[high]) &#123;</div><div class="line">        // array[low] 需要大于等于 array[high] 在内部进行 遍历</div><div class="line">        if ( (low +1 )== high) &#123; //这个很关键，说明只有两个元素</div><div class="line">            return array[high];</div><div class="line">        &#125;</div><div class="line">        if (array[low] == array[high]) &#123;</div><div class="line">            int min = array[low];</div><div class="line">            for ( int i = low +1; i &lt;= high; i++) &#123;</div><div class="line">                if(array[i] &lt; min)&#123;</div><div class="line">                    min = array[i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return min;</div><div class="line">        &#125; else &#123;</div><div class="line">            mid = (low + high) &gt;&gt; 1;</div><div class="line">            if (array[mid] &lt; array[high])&#123;</div><div class="line">                high = mid;</div><div class="line">            &#125; else &#123;</div><div class="line">                low = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 只有一个元素 或者 array[low] &lt; array[high]</div><div class="line">    return array[low];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>05-斐波那契数列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public int Fibonacci(int n) &#123;</div><div class="line">    if(n &lt;= 0) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    if (n == 1 || n == 2) &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">    int preOne = 1;</div><div class="line">    int preTwo = 1;</div><div class="line">    int temp;</div><div class="line">    for ( int i = 3; i &lt;= n; i++ )&#123;</div><div class="line">        temp = preOne;</div><div class="line">        preOne = preOne + preTwo;</div><div class="line">        preTwo = temp;</div><div class="line">    &#125;</div><div class="line">    return preOne;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>06-青蛙跳</p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public int JumpFloor(int target) &#123;</div><div class="line">    if(target &lt;= 0) return 0;</div><div class="line">    if(target == 1) return 1;</div><div class="line">    if(target == 2) return 2;</div><div class="line">    int preOne = 2, preTwo = 1;</div><div class="line">    for(int i = 3; i &lt;= target; i++)&#123;</div><div class="line">        int temp = preOne + preTwo;</div><div class="line">        preTwo = preOne;</div><div class="line">        preOne = temp;</div><div class="line">    &#125;</div><div class="line">    return preOne;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>07-变态青蛙跳</p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public int JumpFloorII(int target) &#123;</div><div class="line">    if(target &lt;= 0) return 0;</div><div class="line">    int result = 1;</div><div class="line">    target --;</div><div class="line">    while(target !=0)&#123;</div><div class="line">        result = result &lt;&lt; 1;</div><div class="line">        target --;</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>08-矩阵覆盖</p>
<blockquote>
<p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> public int RectCover(int target) &#123;</div><div class="line">    if (target &lt;= 0) return 0;</div><div class="line">    if(target == 1) return 1;</div><div class="line">    if(target == 2) return 2;</div><div class="line">    int preOne = 2, preTwo =1;</div><div class="line">    for(int i = 3; i &lt;= target; i++)&#123;</div><div class="line">        int temp = preOne + preTwo;</div><div class="line">        preTwo = preOne;</div><div class="line">        preOne = temp;</div><div class="line">    &#125;</div><div class="line">    return preOne;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>09-二进制中1的个数</p>
<blockquote>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
</blockquote>
<p>思路</p>
<p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public int NumberOf1(int n) &#123;</div><div class="line">    int count = 0;</div><div class="line">    while(n!= 0)&#123;</div><div class="line">        count++;</div><div class="line">        n = n &amp; (n - 1);</div><div class="line">     &#125;</div><div class="line">    return count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>10-数值的整数次方</p>
<blockquote>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public double Power(double base, int exponent) &#123;</div><div class="line">    if (base == 0) &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    boolean flag = false; // 是否exponent是负数</div><div class="line">    if (exponent &lt;= 0) &#123;</div><div class="line">        exponent =  -1 * exponent;</div><div class="line">        flag = true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    double result = 1.0;</div><div class="line">    while (exponent &gt; 0) &#123;</div><div class="line">        result = result * base;</div><div class="line">        exponent--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (flag) &#123;</div><div class="line">        return 1.0 / result; </div><div class="line">    &#125; else &#123;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>11-调整数组顺序奇数在偶数前面</p>
<blockquote>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>二叉搜索树的后序遍历序列</p>
<blockquote>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
</blockquote>
<p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public boolean VerifySquenceOfBST(int [] sequence) &#123;</div><div class="line">   if (sequence == null || sequence.length ==0) &#123;</div><div class="line">       return false;</div><div class="line">   &#125;</div><div class="line">    return verifySequenceOfBST(sequence, 0, sequence.length-1);</div><div class="line"></div><div class="line">&#125;</div><div class="line">private boolean verifySequenceOfBST(int[] sequence,int begin,int end)&#123;</div><div class="line">   if (begin == end) &#123;</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">    int rightBegin = begin;</div><div class="line">    int root = sequence[end];</div><div class="line">    for (;rightBegin &lt; end; rightBegin++ ) &#123;</div><div class="line">        if (sequence[rightBegin] &gt; root ) &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    int i = rightBegin;</div><div class="line">    for (; i &lt; end; i ++ ) &#123;</div><div class="line">        if (sequence[i] &lt; root) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    boolean left = (rightBegin == begin )? true : verifySequenceOfBST(sequence, begin, rightBegin -1);</div><div class="line">    boolean right = (rightBegin == end) ? true : verifySequenceOfBST(sequence, rightBegin+1, end);</div><div class="line">    return left &amp; right;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>复杂链表的复制</p>
<blockquote>
<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
</blockquote>
<p>思路</p>
<p>三步走:</p>
<ol>
<li>在原来链中插入克隆节点，是的克隆节点和源节点相间出现。</li>
<li>复制random指针</li>
<li>从原链从剥离clone链。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">public RandomListNode Clone(RandomListNode pHead)</div><div class="line">&#123;</div><div class="line">    cloneNodes(pHead);</div><div class="line">    connectRandomNodes(pHead); </div><div class="line">    return reconnectNodes(pHead);</div><div class="line">&#125;</div><div class="line">private void cloneNodes(RandomListNode pHead)&#123;</div><div class="line">    RandomListNode node = pHead;</div><div class="line">    while(node != null)&#123;</div><div class="line">        RandomListNode clone = new RandomListNode(node.label);</div><div class="line">        RandomListNode temp = node.next;</div><div class="line">        clone.next = temp;</div><div class="line">        node.next = clone;</div><div class="line">        node = temp;           </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">private void connectRandomNodes(RandomListNode pHead)&#123;</div><div class="line">    RandomListNode node = pHead;</div><div class="line">    while(node != null)&#123;</div><div class="line">         RandomListNode clone = node.next;</div><div class="line">         if(node.random != null)//这里一定要判断</div><div class="line">            clone.random = node.random.next;</div><div class="line">         node = clone.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private  RandomListNode reconnectNodes(RandomListNode pHead)&#123;</div><div class="line">    RandomListNode node = pHead;</div><div class="line">    RandomListNode cloneHead = null;</div><div class="line">    RandomListNode cloneNode = null;</div><div class="line">    if(node != null)&#123;</div><div class="line">        cloneHead = cloneNode = node.next;</div><div class="line">        node.next = cloneNode.next;</div><div class="line">        node = node.next;</div><div class="line">    &#125;</div><div class="line">    while(node != null)&#123;</div><div class="line">        cloneNode.next = node.next;</div><div class="line">        cloneNode = cloneNode.next;</div><div class="line">        node.next = cloneNode.next;</div><div class="line">        node = cloneNode.next;</div><div class="line">    &#125;</div><div class="line">    return cloneHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>二叉搜索树与双向链表</p>
<blockquote>
<p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span></span>&#123;</div><div class="line">        TreeNode lastNode = <span class="keyword">null</span>;</div><div class="line">        lastNode = doConvert(root, lastNode);</div><div class="line">        <span class="keyword">while</span>(lastNode != <span class="keyword">null</span> &amp;&amp; lastNode.left != <span class="keyword">null</span>) &#123;</div><div class="line">            lastNode = lastNode.left;</div><div class="line">        &#125;</div><div class="line">       <span class="keyword">return</span> lastNode;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* 转换并返回链表最后一个结点</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">doConvert</span><span class="params">(TreeNode root, TreeNode lastNode)</span></span>&#123;</div><div class="line">         <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">return</span> lastNode;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</div><div class="line">             lastNode = doConvert(root.left, lastNode);</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span>(lastNode != <span class="keyword">null</span>) &#123;</div><div class="line">             lastNode.right = root;</div><div class="line">         &#125;</div><div class="line">         root.left = lastNode;</div><div class="line">         lastNode = root;</div><div class="line">         <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</div><div class="line">             lastNode = doConvert(root.right, lastNode);</div><div class="line">         &#125;</div><div class="line">        <span class="keyword">return</span> lastNode;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字符串的排列</p>
<blockquote>
<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Collections;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">       ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        doPermutation(str.toCharArray(),<span class="number">0</span>,result);</div><div class="line">        <span class="comment">// 实际中不需要排序</span></div><div class="line">        Collections.sort(result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPermutation</span><span class="params">(<span class="keyword">char</span>[] array,<span class="keyword">int</span> idx,ArrayList&lt;String&gt; result)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(idx &gt;= array.length)&#123;</div><div class="line">            String str = <span class="keyword">new</span> String(array);</div><div class="line">            result.add(str);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=idx; i &lt; array.length; i++)&#123; <span class="comment">//i得从 idx开始</span></div><div class="line">            <span class="keyword">if</span>(i != idx &amp;&amp; array[i] == array[idx] )</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">            swap(array,idx,i);</div><div class="line">            doPermutation(array,idx+<span class="number">1</span>,result);</div><div class="line">            swap(array,idx,i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">        <span class="keyword">char</span> temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-6-Leetcode"><a href="#3-6-Leetcode" class="headerlink" title="3.6 Leetcode"></a>3.6 Leetcode</h2><hr>
<h1 id="第四章-JAVA基础"><a href="#第四章-JAVA基础" class="headerlink" title="第四章 JAVA基础"></a>第四章 JAVA基础</h1><h2 id="4-1-j2se基础"><a href="#4-1-j2se基础" class="headerlink" title="4.1 j2se基础"></a>4.1 j2se基础</h2><ul>
<li><p>值传递和引用传递</p>
<p> java本质上还是值传递，即传入一个变量的副本。如果这个变量是一个对象引用，则方法栈内会创建一个副本指向相同的引用对象，此时对该对象的内容操作会改变该对象，但是无法修改对象引用的值。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Item m)</span></span>&#123;</div><div class="line">   m.name = <span class="string">"new name"</span>; <span class="comment">// m是引用对象n的一个副本，指向n的内存，因此n的值发生变化</span></div><div class="line">   m = <span class="keyword">new</span> Item(); <span class="comment">// 更改副本m的引用指向新的内存，传入对象n指向的内存地址不改变</span></div><div class="line"> &#125;</div><div class="line"> Item n = <span class="keyword">new</span> Item(<span class="string">"name"</span>);</div><div class="line"> change(n);</div></pre></td></tr></table></figure>
</li>
<li><p>静态变量和实例变量的区别</p>
<p>静态变量前要加 static 关键字，静态变量属于类，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，直接使用类名来访问。实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用。</p>
</li>
<li><p>JDK 常见的package</p>
<ul>
<li><strong>java.lang</strong>：这个是系统的基础类，比如 String 等都是这里面的，唯一一个可以不用 import 就可以使用。</li>
<li><strong>java.io</strong>: 这里面是所有输入输出有关的类，比如文件操作等 </li>
<li><strong>java.net</strong>: 这里面是与网络有关的类，比如 URL,URLConnection 等。</li>
<li><strong>java.util</strong>: 这个是系统辅助类，特别是集合类 Collection,List,Map 等。</li>
<li><strong>java.sql</strong>: 这个是数据库操作的类，Connection, Statememt，ResultSet 等</li>
</ul>
</li>
<li><p>JDK, JRE 和 JVM 的区别</p>
<p><strong>JDK, JRE 和 JVM 的区别</strong> JDK 可以编译调试运行java程序， JRE 只能运行 Java 程序。 JDK 和 JRE 都包含了 JVM，JVM是跨平台的。 <strong>即时编译器(JIT)</strong> 是 JVM 的一部分，Java编译器将代码编译成JVM可识别的字节码，而不是机器二进制指令，然后由JIT将字节码转换成与平台相关的机器码指令。</p>
</li>
<li><p>final, finally, finalize 的区别?</p>
<p><strong>final</strong>：(1)修饰类：表示该类不能被继承； (2)修饰方法：表示方法不能被覆盖； (3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<p><strong>finally</strong>：通常放在 try…catch 的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码都能执行，可以将释放外部资源的代码写在 finally 块中。</p>
<p> <strong>finalize</strong>：Object 类中定义的方法finalize()，用于对象被GC回收前执行一些清理工作。GC在销毁对象时调用，通过重写finalize() 方法可以实现整理系统资源或者执行其他清理工作。</p>
</li>
<li><p>assert关键字</p>
<p>assertion(断言)在软件开发中是一种常用的调试方式，assertion <strong>用于保证程序最基本、关键的正确性</strong>。assertion 检查通常在开发和测试时开启。为了提高性能，在软件发布后， assertion 检查通常是关闭的。在实现中，断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为 true；如果表达式计算为 false，那么系统会报告一个 AssertionError。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">assert</span> Expression1;</div><div class="line"><span class="keyword">assert</span> Expression1 : Expression2 ;	<span class="comment">// 表达式2用于输出相关的调试信息</span></div></pre></td></tr></table></figure>
<p>断言在默认情况下是禁用的，要在编译时启用断言，需使用 source 1.4 标记：<code>javac -source 1.4 Test.java</code></p>
<p>要在运行时启用断言，可使用 -enableassertions 或者 -ea 标记。 要在运行时选择禁用断言，可使用 -da 或者 -disableassertions 标记。</p>
</li>
<li><p>char 型变量</p>
<p>char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode，一个 char 类型占 2 个字节（16bit），所以放一个中文是没问题的。在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换，因此Java 中提供了字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader.</p>
</li>
<li><p>String 和StringBuilder、StringBuffer 的区别</p>
<p>String是只读字符串，不可改变对象。 StringBuffer 和 StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是线程不安全的，因此它的效率也比 StringBuffer 略高。  </p>
</li>
<li><p>不可变对象</p>
<p>不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<ul>
<li>将类声明为final，所以它不能被继承</li>
<li>将所有的成员声明为私有的，这样就不允许直接访问这些成员,将所有可变的成员声明为final，这样只能对它们赋值一次</li>
<li>通过构造器初始化所有成员，进行深拷贝(deep copy):如果某一个类成员不是原始变量(primitive)或者不可变类，必须通过在成员初始化(in)或者get方法(out)时通过深度clone方法，来确保类的不可变。</li>
<li>在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝</li>
</ul>
</li>
<li><p>为什么String要设计成不可变的</p>
<ol>
<li>字符串常量池的需要,节约内存空间。</li>
<li>线程安全考虑。 同一个字符串实例可以被多个线程共享。</li>
<li>类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。</li>
<li>支持hash映射和缓存。 </li>
</ol>
<p>Javac 编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在<strong>编译时去掉其中的加号</strong>，直接将其编译成一个这些常量相连的结果。所以 String s=“a”+”b”+”c”+”d”;只生成一个对象.</p>
</li>
<li><p>Java 序列化</p>
<p>序列化就是一种用来处理对象流的机制，用于处理对象流的读写。对象流可以在网络中进行对象传输。</p>
<p>序列化的<strong>实现</strong>：将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法， implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来写流对象，恢复的话则用输入流。</p>
</li>
<li><p>Java持久化</p>
<p>通常将对象由内存保存到硬盘上，使其在程序生命周期之外也可以使用。必须提供Save， Load，boolExist（判断外存是否已有该对象）。</p>
</li>
<li><p>错误和异常(Error vs Exception)</p>
<ol>
<li><strong>java.lang.Error</strong> ，表示系统级的错误和程序不必处理的异常，如内存溢出。<strong>java.lang.Exception</strong> ，表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；二者都是Throwable的子类。</li>
<li>Error 和 RuntimeException 及其子类都是未检查的异常（unchecked exceptions），而所有其他的 Exception 类都是检查了的异常（checked exceptions） 与上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发．发生在编译阶段，必须要使用 try…catch（或者 throws ）否则编译不通过。 unchecked exceptions发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的。比如 类型转换、数组越界访问和试图访问空指针等等。</li>
</ol>
</li>
<li><p>try{} 里的 return 语句</p>
<p>Java 允许在 finally 中改变返回值，因为try 中的 return 语句立即执行，而是记录下返回点，等 finally 代码块执行完毕之后再执行return语句。如果在 finally 中修改了返回值，return的结果也会有相应的改变。</p>
</li>
<li><p>throws、throw、try、catch、finally</p>
<p>try 用来运行一段可能“异常”的代码，catch 子句用来指定想要捕捉的“异常”的类型，并处理；finally，保证无论是否发生“异常”，都会执行finally代码块；throw 语句可以在程序的任意位置主动抛出一个“异常”对象；throws用来标明一个成员函数可能抛出的各种“异常”；</p>
</li>
<li><p>常见的runtime exception</p>
<p>1、<code>NullPointerException</code>空指针引用异常 2、<code>ClassCastException</code>- 类型强制转换异常。 3、<code>IllegalArgumentException</code>- 传递非法参数异常。 4、<code>IndexOutOfBoundsException</code>- 下标越界异常 5、<code>UnsupportedOperationException</code> - 不支持的操作异常 6、<code>ArithmeticException</code> - 算术运算异常 7、<code>ArrayStoreException</code> - 向数组中存放与声明类型不兼容对象异常 8、<code>NegativeArraySizeException</code> - 创建一个大小为负数的数组错误异常 9、<code>NumberFormatException</code> - 数字格式异常 10、<code>SecurityException</code> - 安全异常</p>
</li>
<li><p>equals与==的区别</p>
<ul>
<li>== 是一个运算符,可以用于基本类型的值比较，对象比较则是判断两个引用是否是同一对象。 </li>
<li>equals则是Object提供的对象比较方法，用于判断两个对象引用是否为同一对象（对象大小的比较，是实现Comparable接口）。重写equals方法需要注意：<ol>
<li>使用 instanceof 操作符检查“参数是否为正确的类型”</li>
<li>对于类中的关键属性，检查传入对象的属性是否与之相匹配；</li>
<li>编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性；</li>
<li>重写 equals 时总是要重写 hashCode</li>
<li>不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉 @Override 注解。</li>
</ol>
</li>
</ul>
</li>
<li><p>Object对象提供的方法</p>
<ol>
<li>protected Object clone()创建并返回此对象的一个副本。 </li>
<li>public boolean equals(Object obj)指示其他某个对象是否与此对象“相等”。 </li>
<li>protected void finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 </li>
<li>public final native Class&lt; ? &gt; getClass() 返回此 Object 的运行时类。 </li>
<li>public int hashCode()返回该对象的哈希码值。 </li>
<li>public String toString()返回该对象的字符串表示。 </li>
<li>public void notify()唤醒在此对象监视器上等待的单个线程。 public void notifyAll()唤醒在此对象监视器上等待的所有线程。 </li>
<li>public void wait()在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，阻塞当前线程等待。</li>
</ol>
<p>注意： 对象必须实现Cloneable标示性接口，才能调用Clone方法，否则会有<code>CloneNotSupportedException</code> 异常。</p>
<p>在每个覆盖equals方法的类中也必须覆盖hashCode方法，由于hashCode的通用约定—相等的对象散列码相等，可以保证所有基于散列集合的操作运行正常，如HashMap,HashSet和HashTable。hashMap根据hashCode去定位散列桶位置。</p>
</li>
<li><p>修饰符顺序</p>
<p>public protected private abstract static final transient volatile synchronized native strictfp</p>
</li>
</ul>
<h2 id="4-2-面向对象"><a href="#4-2-面向对象" class="headerlink" title="4.2 面向对象"></a>4.2 面向对象</h2><p>面向对象软件开发的优点： (1) 代码开发模块化，更易维护和修改。 (2) 代码复用。 (3) 增强代码的可靠性和灵活性。 (4) 增加代码的可理解性。 面向对象编程有很多重要的特性如：封装，继承，多态和抽象。</p>
<ul>
<li><p>Overload 和 Override</p>
<p><strong>重载 Overload</strong> 表示<strong>同一个类</strong>中可以有多个名称相同的方法，但这些方法的参数类型、数量不同。 不能通过访问权限、返回类型、抛出异常实现重载。</p>
<p><strong>重写 Override</strong> 表示<strong>子类</strong>中的方法可以与<strong>父类</strong>中的某个<strong>方法的名称和参数完全相同</strong>，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。<strong>子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常</strong>，因为子类可以解决父类的一些问题，不能比父类有更多的问题。<strong>子类方法的访问权限只能比父类的更大，不能更小</strong>。如果<strong>父类的方法是 private 类型，那么，子类则不存在覆盖的限制</strong>，相当于子类中增加了一个全新的方法。 </p>
</li>
<li><p>接口和抽象类的区别</p>
<ol>
<li>接口中所有的<strong>方法</strong>隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。 </li>
<li>类可以实现很多个接口，但是只能<strong>继承</strong>一个抽象类 </li>
<li>类如果要<strong>实现</strong>一个接口，它必须要实现接口声明的所有方法。类在声明成是抽象的情况下，可以不实现抽象类声明的所有方法。  </li>
<li>Java 接口中声明的<strong>变量</strong>默认都是 final 的.抽象类可以包含非 final 的变量。 </li>
<li>Java 接口中的<strong>成员函数</strong>默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public 。 </li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也无法实例化，但是可以调用main方法。</li>
</ol>
</li>
<li><p>接口</p>
<ol>
<li>接口的变量都是 <code>public static final</code> ,相当于常量，是所有实现类的共有变量。 方法都是<code>public abstract</code> </li>
<li>没有构造函数和实例变量，没法被实例化。</li>
</ol>
</li>
<li><p>AOP 和 OOP，IOC 和 DI</p>
<ol>
<li><p>面向对象编程（Object Oriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。</p>
</li>
<li><p>AOP 是 OOP 的延续，是 Aspect Oriented Programming 的缩写，意思是面向方面编程。 将通用需求功能从不相关类之中分离出来；同时，能够使得很多类共享一个行为，一旦行为发生变化，不必修改很多类，只要修改这个行为就可以。AOP 就是这种实现分散关注的编程方法，它将“关注”封装在“方面”中。</p>
<p>类比Python的装饰器语法，可以在函数运行时，改变函数的运行。</p>
</li>
<li><p>控制反转 IOC(Inversion of Control) 控制指的就是程序相关类之间的依赖关系.传统观念设计中, 通常由调用者来创建被调用者的实例, <strong>在 Spring 里,创建被调用者的工作不再由调用者来完成,而是由 Spring 容器完成，依赖关系被反转了，称为控制反转，目的是为了获得更好的扩展性和良好的可维护性</strong>。依赖注入(Dependency injection)创建被调用者的工作由 Spring 容器完成，然后注入调用者，因此也称依赖注入。控制反转和依赖注入是<strong>同一个概念</strong>。</p>
</li>
</ol>
</li>
</ul>
<h2 id="4-3-集合"><a href="#4-3-集合" class="headerlink" title="4.3 集合"></a>4.3 集合</h2><p>Collection：List列表，Set集合， Map：Hashtable，HashMap，TreeMap</p>
<ul>
<li><p><strong>List</strong> 列表，元素有序，可重复，能够使用索引访问元素。List接口的常用实现类： Vector，线程安全但速度慢，底层数据结构是数组；ArrayList，线程不安全但查询速度快，底层数据结构是数组； LinkedList，线程不安全，增删速度快，底层数据结构是链表。</p>
</li>
<li><p><strong>Set</strong>(集) 元素不可重复，无序。 取出元素的方法只有迭代器。 Set接口中常用的类 HashSet：线程不安全，内部是基于散列函数实现,存取速度快。依赖元素的hashCode方法和euqals方法确保唯一性； LinkedHashSet，具有HashSet的查询速度，且内部采用双向链表<strong>维护元素的顺序</strong> ，内部是由链表实现；TreeSet，线程不安全，可以对Set集合中的元素进行排序,内部采用了红黑树。通过元素的compareTo或者compare方法来保证元素的唯一性。元素是以二叉树的形式存放的。TreeSet中的元素要实现Comparable接口，或者有一个自定义的比较器。</p>
</li>
<li><p><strong>Map</strong>，key-value的形式保存索引和数据。Hashtable，线程安全，速度快。底层是<strong>哈希表数据</strong>结构，不允许null作为key和值；Properties:用于配置文件的定义和操作，使用频率非常高，同时键和值都是字符串；HashMap，线程不安全，速度慢。底层也是哈希表数据结构，但是允许null作为键和值；LinkedHashMap，可以保证HashMap集合有序。存入的顺序和取出的顺序一致；TreeMap，可以对Map中的键进行排序，底层是采用红黑树． </p>
</li>
<li><p>Collection 和 Collections的区别： Collection是集合类的上级接口，子接口主要有Set 和List、Map。 Collections是针对集合类的实现的工具类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p>
</li>
<li><p>ArrayList 和 LinkedList</p>
<p>底层实现不同，ArrayList使用数组，查询快；LinkedList使用链表，插入删除速度快；</p>
</li>
<li><p>遍历List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//使用for-each循环</span></div><div class="line"><span class="keyword">for</span>(String obj : strList)&#123;</div><div class="line">  System.out.println(obj);</div><div class="line">&#125;</div><div class="line"><span class="comment">//using iterator</span></div><div class="line">Iterator&lt;String&gt; it = strList.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">  String obj = it.next();</div><div class="line">  System.out.println(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>LinkedList 和PriorityQueue 的区别</p>
<p><strong>Queue中只有两个实现类LinkedList 和PriorityQueue</strong>。他们都是属于队列，即拥有先进先出（FIFO）的特点。LinkedList 支持双向列表操作， PriorityQueue 按优先权控制队列元素的出队次序（Comparable接口）。</p>
</li>
<li><p>HashMap实现原理</p>
<p><strong>数据结构</strong>： HashMap基于哈希算法，采用链地址法来避免hash冲突，所以其内部采用链表数组数据结构。我们通过put()和get()方法储存和获取对象。HashMap里面实现一个静态内部类Entry, Entry用于保存key、value, next为链表指针.</p>
<p><strong>存取实现</strong>:  <strong>put</strong> ，根据对象的hashCode计算得到<strong>散列桶坐标</strong>（数组下表），由于数组中存放的是<strong>Entry链表结构</strong>，然后遍历Entry链表，如果存在key则更新其Value，如果不存在则<strong>采用头插入</strong>的方式在链表头部插入一个新的Entry节点存储key-value。 <strong>null key</strong>总是存放在Entry[]数组的第一个元素。 </p>
<p><strong>get</strong>, 根据hashCode的值定位到散列桶，并遍历存放在改桶中的链表。如果存在的该key则返回对应的value，如果不存在则返回null。</p>
<p><strong>解决hash冲突</strong>：1.开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列） 2.再哈希法 3.链地址法 4.建立一个公共溢出区。 Java的HashMap使用的是链地址法。</p>
</li>
<li><p>Enumeration 接口和 Iterator 接口的区别</p>
<p>Enumeration 速度是 Iterator 的2倍，<strong>同时占用更少的内存</strong>。 但是，Iterator远远比 Enumeration 安全，因为其他线程不能够修改正在被 iterator 遍历的集合里面的对象。 同时，Iterator 允许调用者删除底层集合里面的元素。</p>
</li>
<li><p>迭代器fail-fast属性</p>
<p>每次尝试获取下一个元素的时候，Iterator fail-fast属性检查当前集合结构里的任何改动。如果发现任何改动，它抛出ConcurrentModificationException。Collection中所有Iterator的实现都是按fail-fast来设计。在遍历一个集合的时候，我们可以使用并发集合类来避免ConcurrentModificationException，比如使用CopyOnWriteArrayList，而不是ArrayList</p>
</li>
<li><p>快速失败(fail-fast)和安全失败(fail-safe)的区别</p>
<p>Iterator的fail-fast属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</p>
</li>
<li><p>Map接口提供的集合视图</p>
<ol>
<li><strong>Set keyset()</strong>：返回map中包含的所有key的一个Set视图。</li>
<li><strong>Collection values()</strong>：返回一个map中包含的所有value的一个Collection视图。 </li>
<li>Set&lt; Map.Entry &lt; K,V &gt; &gt; entrySet()：返回一个map钟包含的所有映射的一个集合视图。</li>
</ol>
<p>注意： 上面三个方法得到的集合对象是Map里的引用对象，都不支持add添加元素，但是支持移除和修改，相应的Map对象元素内容也会发生改变。</p>
</li>
<li><p>EnumSet</p>
<p>java.util.EnumSet是使用<strong>枚举类型</strong>的集合实现。当集合创建时，枚举集合中的所有元素必须来自单个指定的枚举类型，可以是显示的或隐示的。</p>
</li>
<li><p>集合对象排序</p>
<p>可以使用Arrays.sort()或Collections.sort()方法。</p>
</li>
<li><p>Comparable和Comparator接口</p>
<p> 都是用来实现集合中元素的比较、排序的。只是 Comparable 用于实现对象自比较。Comparator 实现两个对象的比较。</p>
<p>Comparator里有compare(T o1,T o2)和equals(Object obj)，Comparable接口只有int compareTo(T o)方法。</p>
</li>
</ul>
<h2 id="4-4-多线程"><a href="#4-4-多线程" class="headerlink" title="4.4 多线程"></a>4.4 多线程</h2><p>并发编程常见的3个问题：原子性，可见性(共享变量修改对其他线程立即可用)，有序性。</p>
<ul>
<li><p>volatile的理解</p>
<ol>
<li>Volatile 是轻量级的synchronized，它在多处理器开发过程中保证了共享变量的“可见性”，可见性是指当一个线程的某个共享变量发生改变时，另一个线程能够读取到这个修改的值。</li>
</ol>
</li>
</ul>
<ol>
<li>Volatile 可以禁止指令重排序。</li>
<li>Volatile 能保持单个简单volatile变量的读/写操作的具有原子性。但不能保证自增自减的原子性。</li>
</ol>
<ul>
<li><p>死锁的必要条件？怎么克服？</p>
<p>答：产生死锁的四个必要条件： <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。 <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 <strong>不剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能被强行剥夺。 <strong>循环等待条件</strong>。 只要上述条件之一不满足，就不会发生死锁。</p>
</li>
<li><p>ThreadPool</p>
<p>创建和销毁线程需要代价，线程执行完毕不销毁而是存入线程池中。</p>
<ol>
<li><p>execute 和submit的区别</p>
<p>Execute()用于提交不需要返回值得任务，submit()用于提交需要返回值的任务，发挥Future类型的对象。</p>
</li>
<li><p>Shutdown和shutdownNow的区别</p>
<p>都是遍历线程池中的工作线程，然后逐个调用线程的Internet方法来中断线程，所以无法响应中断的任务可能永远无法终止。 ShutdownNow首先将线程池的状态设置成STOP,然后尝试停止所有正在执行或暂停的任务，并返回等待执行任务的列表。而shutdown只是将线程池设置成SHUTDOWN状态，然后中断没有正在执行任务的线程。</p>
</li>
</ol>
</li>
<li><p>ThreadLocal</p>
<p>ThreadLocal并不是一个Thread，而是Thread的局部变量,当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，一个线程不会影响其它线程所对应的变量副本</p>
</li>
<li><p>同步</p>
<ol>
<li><p>sleep() 和 wait() 区别</p>
<p>sleep()是Tread的方法，可以让线程暂停执行指定时间，将执行机会给其他线程，但是依然保持监控状态，到时后线程变为ready状态，因此调用 sleep后线程 不会释放对象锁。wait() 是 Object 类的方法，调用 wait()方法导致本线程放弃对象锁(线程暂停执行)，然后等待针对此对象发出 notify 方法（或 notifyAll），本线程才能获得对象锁，进入就绪状态。</p>
</li>
<li><p>sleep() 和 yield() 区别</p>
<p>sleep方法给其他线程运行机会时<strong>不考虑线程的优先级</strong>，因此低优先级的线程也有运行的机会；yield方法<strong>只会给相同优先级或更高优先级</strong>的线程以运行的机会；</p>
<p>sleep() 方法后线程转入<strong>阻塞</strong>（blocked）状态，而执行 yield方法后线程转入<strong>就绪（ready）</strong>状态；</p>
<p>sleep() 方法声明需要抛出InterruptedException，而 yield() 方法没有声明任何异常；</p>
</li>
</ol>
</li>
<li><p>实现多线程的3种方法：Thread与Runable。 <strong>1)继承Tread类，重写run函数</strong> <strong>2)实现Runnable接口</strong> <strong>3)实现Callable接口</strong></p>
<ul>
<li>Callable和Runnable的区别</li>
</ul>
</li>
</ul>
<h2 id="4-5-IO"><a href="#4-5-IO" class="headerlink" title="4.5 IO"></a>4.5 IO</h2><h2 id="4-6-设计模式"><a href="#4-6-设计模式" class="headerlink" title="4.6 设计模式"></a>4.6 设计模式</h2><p>设计模式：单例、工厂、适配器、责任链、观察者等等。</p>
<h2 id="4-7-JVM"><a href="#4-7-JVM" class="headerlink" title="4.7 JVM"></a>4.7 JVM</h2><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p>
<p><img src="http://img.shuaiyy.cn/blog/180314/2KB71gC0j2.png?imageslim" alt="mark"></p>
<ul>
<li><strong>程序计数器</strong>：看做当前线程所执行的<strong>字节码行号指示器</strong>。是线程<strong>私有</strong>的内存，且唯一一块不报OutOfMemoryError异常。</li>
<li><strong>Java虚拟机栈</strong>：用于描述java方法的<strong>内存模型</strong>：每个方法被执行时都会同时创建一个<strong>栈帧</strong>用于存储<strong>局部变量表，操作数栈，动态链接，方法出口</strong>等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的深度就报StackOverflowError, 如果虚拟机栈可以动态<strong>扩展</strong>，当拓展时无法申请到足够的内存会抛出OutOfMemoryError. 是线程<strong>私有</strong>的。</li>
<li><strong>本地方法栈</strong>：与虚拟机栈相似，不同的在于它是为虚拟机使用到的<strong>Native</strong>方法服务的。会抛出StackOverflowError和OutOfMemoryError。是线程<strong>私有</strong>的。</li>
<li><strong>Java堆</strong>:是所有线程共享的一块内存，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。如果堆上没有内存完成实例的分配就会报OutOfMemoryError.</li>
<li><strong>方法区（永久代）</strong>：用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。是共享内存。</li>
<li><strong>运行时常量池</strong>：用于存放编译器生成的各种字面量和符号引用，是方法区的一部分。无法申请内存时抛出OutOfMemoryError。</li>
<li><strong>直接内存</strong>：不是虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的区域，是计算机直接的内存空间。这部分也被频繁使用，如JAVA NIO的引入基于通道和缓存区的I/O使用native函数直接分配堆外内存。如果内存不足会报OutOfMemoryError。</li>
</ul>
<p>GC的两种判定方法：引用计数与根搜索算法。 </p>
<ul>
<li><strong>引用计数</strong>： 给对象添加一个引用计数器，每当有一个地方引用该对象时，计数器值加1，当引用失效时，计数器值减1。任何时候计数器都为0的对象就是不可能再被使用的。它很难解决对象之间相互<strong>循环引用</strong>问题。</li>
<li><strong>根搜索算法（GC Roots Traceing）:</strong> 通过一系列名为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索走过的路径成为<strong>引用链</strong>，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。 GC Roots对象一般是：虚拟机栈中的引用对象，方法区中类静态属性引用的对象，方法区常量引用的对象等。</li>
</ul>
<p>Java中的四种对象引用，可以通过代码决定某些对象的生命周期，同时利于JVM进行垃圾回收。</p>
<ol>
<li><strong>强引用</strong>：程序代码中的普通引用。如Object obj = new Object(),只要强引用存在，垃圾回收器就不会回收。在不使用对象时应及时将引用设置为null，便于垃圾回收。 </li>
<li><strong>软引用</strong>：描述一些有用但并非必须的对象。对于软引用关联的对象在系统将要<strong>发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之中进行第二次回收。</li>
<li><strong>弱引用</strong>：描述非必须对象，比软引用弱一些。被弱引用关联的对象只能<strong>生存到下一次垃圾收集发生之前</strong>。无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 </li>
<li><strong>虚引用</strong>：最弱的引用，不管是否有虚引用存在，完全不会对对象生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的是希望能够在这个对象被垃圾回收器之前收到系统通知。</li>
</ol>
<p>内存溢出和内存泄漏</p>
<ol>
<li><strong>内存溢出</strong>：通俗理解就是<strong>内存不够</strong>，程序所需要的内存远远超出了你虚拟机分配的内存大小</li>
<li><strong>内存泄露</strong>：动态分配的内存空间使用完毕之后未回收</li>
</ol>
<p>内存溢出了怎么办？</p>
<p>​    通过内存映像工具如jhat,jconsole等对dump出来的堆转存储快照进行分析，确认内存是出现内存泄露还是内存溢出。</p>
<ul>
<li>如果是<strong>内存泄露</strong>进一步使用工具查看泄露的对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们。掌握泄露对象的信息，以及GC Roots引用链的信息，就可以比较准确定位泄露代码的位置。 </li>
<li>如果是<strong>内存溢出</strong>，那就需要通过jinfo，Jconsole等工具分析java堆参数与机器物理内存对比是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态过长的情况，尝试减少程序的运行消耗。</li>
</ul>
<p>Java 中有内存泄露吗？</p>
<ol>
<li><strong>长生命周期</strong>的对象持有<strong>短生命周期对象</strong>的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，例如缓存系统中，加载了一个对象放在缓存中，然后一直不再使用它，造成内存泄露。</li>
<li>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，也不会被垃圾回收，造成内存泄露。 </li>
</ol>
<p>GC的三种收集方法</p>
<ol>
<li><strong>标记清理</strong>：首先标记所有需要回收的对象，在标记完成后<strong>统一回收掉</strong>所有被标记的对象，它的标记的对象。缺点是<strong>效率低</strong>，且存在<strong>内存碎片</strong>。主要用于老生代垃圾回收。 </li>
<li><strong>复制算法</strong>：将内存按容量划分为大小相等的一块，每次只用其中一块。当内存用完了，将还存活的对象复制到另一块内存，然后把已使用过的内存空间一次清理掉。实现简单，高效。一般用于新生代。一般是将内存分为一块较大的Eden空间和两块较小的Survivor空间。HotSpot虚拟机默认比例是8:1,。每次使用Eden和一块Survivor，当回收时将这两块内存中还存活的对象复制到Survivor然后清理掉刚才Eden和Survivor的空间。如果复制过程内存不够使用则向老年代分配担保。</li>
<li><strong>标记整理</strong>：首先标记所有需要回收的对象，在标记完成后让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存。用于老年代。 </li>
</ol>
<p>JVM 加载 class 文件的原理机制</p>
<ul>
<li>类加载的五个过程：加载、验证、准备、解析、初始化。</li>
<li>类加载器把类的 .class 文件中的数据读入到内存中，然后进入连接阶段，这一阶段包括验证(确保class文件对JVM合法)、准备(为静态变量分配内存并设置默认的初始值)和解析(将常量池的符号引用替换为直接引用)三个步骤。最后 JVM 对类进行初始化，包括：初始化直接父类，执行类中的构造方法。</li>
</ul>
<p>Student s= new Student(),在内存中做了那些事情</p>
<ol>
<li>加载Student.class 文件进内存</li>
<li>在栈内存为s开辟空间</li>
<li>在堆内存为Student对象开辟空间</li>
<li>学生对象的成员变量进行显示初始化</li>
<li>通过构造方法对学生对象变量赋值</li>
<li>学生对象初始完毕，把对象地址赋值给s变量</li>
</ol>
<h2 id="JVM常用参数配置"><a href="#JVM常用参数配置" class="headerlink" title="JVM常用参数配置"></a>JVM常用参数配置</h2><ul>
<li>-Xms ：表示初始堆大小,默认为物理内存的1/64(&lt;1GB)，默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</li>
<li>-Xmx :最大堆大小,物理内存的1/4(&lt;1GB),(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</li>
<li>-Xmn ：年轻代大小(1.4or lator),注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的整个堆大小=年轻代大小 + 年老代大小 + 持久代大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8</li>
<li>-XX:NewSize :设置年轻代大小(for 1.3/1.4)</li>
<li>-XX:MaxNewSize :年轻代最大值(for 1.3/1.4)</li>
<li>-XX:PermSize 设置持久代(perm gen)初始值，物理内存的1/64</li>
<li>-XX:MaxPermSize ：设置持久代最大值，物理内存的1/4 </li>
</ul>
<hr>
<h1 id="第五章-数据库"><a href="#第五章-数据库" class="headerlink" title="第五章 数据库"></a>第五章 数据库</h1><h2 id="存储引擎的区别"><a href="#存储引擎的区别" class="headerlink" title="存储引擎的区别"></a>存储引擎的区别</h2><p><strong>InnoDB</strong>: 支持事务，是面向在线事务处理(OLTP)的应用,特点是<strong>行锁设计</strong>，支持外键，并支持一致性非锁定读，即默认情况下读取操作不会产生锁．是默认的<strong>存储引擎</strong>:．还提供了插入缓冲，二次写，自适应哈希索引，预读等高性能和高可用的功能． </p>
<p><strong>MyISAM</strong>: 不支持事务，是表锁设计和支持全文索引，主要面向一些OLAP的数据库应用.它的缓冲池只缓冲索引文件，而不缓冲数据文件．该存储引擎表由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件.</p>
<p> <strong>NDB</strong>:是一个集群存储引擎，其特点是数据全部放在内存中，因此主键查找速度极快，并通过添加NDB数据库存储节点可以线性提高数据库性能，是高可用，高性能的集群系统． </p>
<p><strong>Memory</strong>: 将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据库都将消失，它非常适合存储临时数据的临时表．默认采用哈希索引． </p>
<p><strong>Archive</strong>: 只支持INSERT和SELECT操作，使用zlib算法将数据行进行压缩，压缩比可以达到1:10，非常适合存储归档数据.但其本身不是事务安全的存储引擎，其设计目标是提供高速的插入和压缩功能． </p>
<p><strong>Federated</strong>: 并不存放数据，它只是指向一台远程MySQL数据库服务器上的表. </p>
<p><strong>Maria存储引擎</strong>:　设计目标主要是用来取代原有的MyISAM存储引擎．</p>
<h2 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h2><ol>
<li>MyISAM是非事务安全型的，而InnoDB是事务安全型的。</li>
<li>MyISAM锁的粒度是表级，而InnoDB支持行级锁定。</li>
<li>MyISAM支持全文索引，而Innodb不支持全文索引</li>
<li>MyISAM表是保存成文件形式的，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。</li>
<li>InnoDB表比MyISAM表更安全，可以保证数据不丢失的情况下，切换非事务表到事务表</li>
</ol>
<h3 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a>sql注入原理</h3><ul>
<li>在用户传递的参数中插入SQL命令，最终达到欺骗服务器执行恶意的SQL命令。</li>
<li>防注入：限制字符长度，对特殊字符转义。 后台不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 不要使用root权限建立数据库连接。重要信息加密存储。 数据库异常信息不应暴露给用户。</li>
</ul>
<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><p>索引是一个单独存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针，使用索引可以提高数据库特定数据的查询速度.索引时在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同,并且每种存储引擎也不一定支持所有索引类型．</p>
<p>索引的存储类型有两种：BTREE和HASH,具体和表的存储引擎有关．MyISAM和InnoDB存储引擎只支持BTREE;MEMORY/HEAD存储索引可以支持HASH和BTREE索引． <strong>索引的优点</strong>:</p>
<ol>
<li>通过创建唯一索引，可以保证数据库表中每行数据的唯一性.</li>
<li>可以加快数据的查询速度．</li>
<li>在实现数据的参考完整性方面，可以加速表和表之间的连接．</li>
<li>再使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能。</li>
</ol>
<p><strong>索引的缺点</strong>：</p>
<ol>
<li>创建索引和维护索引要耗费时间，并且随着数据量的增加耗费时间也增加．</li>
<li>索引需要占空间内存．</li>
<li>在对表中数据进行增加,删除和修改的时候，索引也需要动态维护，这样降低了数据维护速度．</li>
</ol>
<p><strong>索引分类</strong></p>
<ol>
<li>普通索引和唯一索引</li>
<li>直接创建索引和间接创建索引</li>
<li>普通索引和唯一性索引</li>
<li>单个索引和符合索引</li>
<li>聚簇索引和非聚簇索引</li>
</ol>
<p><strong>索引失效</strong>？？</p>
<ol>
<li>WHERE字句的查询条件里有不等于号（WHERE column!=…），MYSQL将无法使用索引</li>
<li>如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=…），MYSQL将无法使用索引</li>
<li>在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用。</li>
<li>如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE ‘abc%’,MYSQL将使用索引；如果条件是LIKE ‘%abc’，MYSQL将不使用索引。</li>
<li>在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用。</li>
<li>如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。</li>
<li>如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。</li>
<li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引。</li>
</ol>
<h2 id="数据库锁机制"><a href="#数据库锁机制" class="headerlink" title="数据库锁机制"></a>数据库锁机制</h2><p>数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问，访问变得有序所设计的一种规则。MySQL各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。MySQL数据库中，使用表级锁定的主要是MyISAM，Memory，CSV等一些非事务性存储引擎，而使用行级锁定的主要是Innodb存储引擎和NDBCluster存储引擎，页级锁定主要是BerkeleyDB存储引擎的锁定方式。</p>
<ul>
<li>表级锁定（table-level）：表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。表级锁分为读锁和写锁。</li>
<li>页级锁定（page-level）：页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。</li>
<li>行级锁定（row-level）：行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。InnoDB的行级锁同样分为两种，共享锁和排他锁，同样InnoDB也引入了意向锁（表级锁）的概念，所以也就有了意向共享锁和意向排他锁，所以InnoDB实际上有四种锁，即共享锁（S）、排他锁（X）、意向共享锁（IS）、意向排他锁（IX）；</li>
<li>MyISAM 表锁优化建议： 1、缩短锁定时间 2、分离能并行的操作 3、合理利用读写优先级</li>
</ul>
<p><strong>悲观锁</strong>:它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。</p>
<p> <strong>乐观锁（ Optimistic Locking ）</strong> :相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则则拒绝更新并返回用户错误的信息，让用户决定如何去做。乐观锁由程序实现，不会存在死锁问题。它适用的场景也相对乐观。但乐观锁不能解决脏读的问题</p>
<p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p>
<h2 id="数据库连接池原理"><a href="#数据库连接池原理" class="headerlink" title="数据库连接池原理"></a>数据库连接池原理</h2><p><strong>背景</strong></p>
<p>数据库连接的创建和关闭需要一定的开销，频繁的建立、关闭数据库，增大系统开销，另外还必须管理每一个连接，以确保他们能正确关闭，否则会导致内存溢出。</p>
<p><strong>原理</strong></p>
<p>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。以及一套连接使用、分配、管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。我</p>
<hr>
<h1 id="第六章-框架和组件"><a href="#第六章-框架和组件" class="headerlink" title="第六章 框架和组件"></a>第六章 框架和组件</h1><h2 id="6-1-spring"><a href="#6-1-spring" class="headerlink" title="6.1 spring"></a>6.1 spring</h2><p><strong>Spring优点</strong></p>
<ul>
<li><strong>轻量级</strong>：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。</li>
<li><strong>控制反转(IOC)</strong>：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。 </li>
<li><strong>面向切面编程(AOP)</strong>： Spring支持面向切面编程，同时把应用的<strong>业务逻辑与系统的服务分离开来</strong>。</li>
<li><strong>容器</strong>：Spring包含并管理应用程序对象的配置及生命周期。</li>
<li><strong>MVC框架</strong>：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。</li>
<li><strong>事务管理</strong>：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。</li>
<li><strong>异常处理</strong>：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</li>
</ul>
<p><strong>Spring框架模块</strong></p>
<p> <strong>核心容器模块</strong>：是spring中最核心的模块。负责Bean的创建，配置和管理。主要包括：beans, core, context, expression等模块。 <strong>AOP模块</strong>：主要负责对面向切面编程的支持，帮助应用对象解耦。 <strong>数据访问和集成模块</strong>：包括JDBC，ORM，OXM，JMS和事务处理模块。<strong>Web和远程调用</strong>：包括web,servlet,struts,portlet模块。 <strong>测试模块</strong>, <strong>工具模块</strong> <strong>消息模块</strong></p>
<ul>
<li><p>什么是控制反转(IOC)？什么是依赖注入？</p>
<p>传统模式中对象的调用者需要创建被调用对象，两个对象过于耦合，不利于变化和拓展．在spring中，直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理，从而实现对象之间的松耦合。所谓的“控制反转”概念就是对组件对象控制权的转移，从程序代码本身转移到了外部容器。 <strong>依赖注入</strong>：对象无需自行创建或管理它们的依赖关系，IoC容器在运行期间，动态地将某种依赖关系注入到对象之中。依赖注入能让相互协作的软件组件保持松散耦合。</p>
</li>
<li><p>BeanFactory和ApplicationContext有什么区别？</p>
<p>Bean工厂(BeanFactory)是Spring框架最核心的接口，提供了高级Ioc的配置机制．应用上下文(ApplicationContext)建立在BeanFacotry基础之上，提供了更多面向应用的功能，如果国际化，属性编辑器，事件等等．beanFactory是spring框架的基础设施，是面向spring本身，ApplicationContext是面向使用Spring框架的开发者，几乎所有场合都会用到ApplicationContext.</p>
</li>
<li><p>Spring有几种配置方式？</p>
<ol>
<li>基于XML的配置</li>
<li>基于注解的配置，可以用注解的方式来替代XML方式对bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。</li>
<li>基于Java的配置：由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。</li>
</ol>
</li>
</ul>
<ul>
<li><p>Spring Bean的作用域之间有什么区别</p>
<p>singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</p>
<p> prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。 </p>
<p>request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。 </p>
<p>Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。 global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。</p>
</li>
</ul>
<ul>
<li><p>Spring 框架中都用到了哪些设计模式</p>
<ol>
<li><strong>代理模式</strong>—在AOP和remoting中被用的比较多。</li>
<li><strong>单例模式</strong>—在spring配置文件中定义的bean默认为单例模式。 </li>
<li><strong>模板方法</strong>—用来解决代码重复的问题 比如. RestTemplate, JmsTemplate, JpaTemplate。 前端控制器—Srping提供了DispatcherServlet来对请求进行分发。 视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。 依赖注入—贯穿于BeanFactory  /  ApplicationContext 接口的核心理念。 </li>
<li><strong>工厂模式</strong>—BeanFactory用来创建对象的实例。 </li>
<li><strong>Builder模式</strong> - 自定义配置文件的解析bean是时采用builder模式，一步一步地构建一个beanDefinition </li>
<li><strong>策略模式</strong> ：Spring 中策略模式使用有多个地方，如 Bean 定义对象的创建以及代理对象的创建等。这里主要看一下代理对象创建的策略模式的实现。 </li>
</ol>
</li>
<li><p>AOP是怎么实现的</p>
<p>实现AOP的技术，主要分为两大类：</p>
<ol>
<li>动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；</li>
<li>静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</li>
</ol>
</li>
</ul>
<ul>
<li>springMVC流程具体叙述下<ol>
<li>应用启动时,容器会加载servlet类并调用init方法. 在这个阶段，DispatcherServlet在init()完成初始化参数init-param的解析和封装,相关配置,spring的WebApplicationContext的初始化即完成xml文件的加载,bean的解析和注册等工作,另外为servlet功能所用的变量进行初始化,如:handlerMapping,viewResolvers等.</li>
<li>收到一个请求时，首先根据请求的类型调用DispatcherServlet不同的方法，这些方法都会转发到doService()中执行．根据request信息获取对应的Handler. 首先根据request获取访问路径,然后根据该路径URL匹配对应规则的Handler,调用Handler处理。</li>
</ol>
</li>
</ul>
<ul>
<li>ioc注入的方式</li>
</ul>
<p>1)setter方法注入 2)构造器注入3)静态工厂注入 factory-method参数 4)实例工厂 &lt;&gt;</p>
<ul>
<li>AOP相关概念<ol>
<li><strong>方面（Aspect）</strong>：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</li>
<li><strong>连接点（Joinpoint）</strong>: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</li>
<li><strong>通知（Advice）:</strong> 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。</li>
<li><strong>切入点（Pointcut）</strong>: 一系列连接点的集合。</li>
<li><strong>引入（Introduction）</strong>: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor 来配置Advice和代理类要实现的接口 </li>
<li><strong>目标对象（Target Object）</strong>: 包含连接点的对象。也被称作被通知或被代理对象。POJO</li>
<li><strong>AOP代理（AOP Proxy）</strong>: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li>
<li><strong>织入（Weaving）</strong>: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
</ol>
</li>
</ul>
<ul>
<li><p>过滤器与监听器的区别</p>
<p>过滤器Filter，是一个变种servlet，无法直接返回给用户response，但是可以链式处理request、response。</p>
</li>
</ul>
<ul>
<li><p>Spring Beans</p>
<p>Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。 在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。</p>
</li>
<li><p>Spring Bean中定义了什么内容？</p>
<p>Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。</p>
</li>
</ul>
<h2 id="6-2-spring-MVC"><a href="#6-2-spring-MVC" class="headerlink" title="6.2 spring-MVC"></a>6.2 spring-MVC</h2><h2 id="6-3-Mybatis"><a href="#6-3-Mybatis" class="headerlink" title="6.3 Mybatis"></a>6.3 Mybatis</h2><h1 id="第七章-面试"><a href="#第七章-面试" class="headerlink" title="第七章 面试"></a>第七章 面试</h1><h2 id="7-1-语言基础"><a href="#7-1-语言基础" class="headerlink" title="7.1 语言基础"></a>7.1 语言基础</h2><h2 id="7-2-算法"><a href="#7-2-算法" class="headerlink" title="7.2 算法"></a>7.2 算法</h2><h2 id="7-3-项目"><a href="#7-3-项目" class="headerlink" title="7.3 项目"></a>7.3 项目</h2>
      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/学习/">学习</a>, <a href="/categories/学习/求职/">求职</a>, <a href="/categories/学习/求职/基础知识/">基础知识</a>
  </div>

        
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 23px; color: #f00">Java</a> <a href="/tags/求职/" style="font-size: 13px; color: #90f">求职</a>
    </div>




<!-- 打赏按钮开始 -->

    <br>
<br>
<div id="donate"></div>

<script src="https://unpkg.com/vdonate"></script>
<script type="text/javascript">
new Donate({
  title: '如果我的博客帮助了您，请随意打赏。感谢支持!', // 可选参数，打赏标题
  btnText: '打赏作者', // 可选参数，打赏按钮文字
  el: document.getElementById('donate'), // 可选参数，打赏按钮的容器
  wechatImage: 'http://img.shuaiyy.cn/blog/171004/9h7fIfcILJ.png',
  alipayImage: 'http://img.shuaiyy.cn/blog/171004/KLLJdiLg9c.jpg'
});
</script>

<script>
window.onload = function(){
 var oTop = document.getElementById("donate");
 var screenw = document.documentElement.clientWidth || document.body.clientWidth;
 var screenh = document.documentElement.clientHeight || document.body.clientHeight;
 oTop.style.left = screenw - oTop.offsetWidth +"px";
 oTop.style.top = screenh - oTop.offsetHeight + "px";
 window.onscroll = function(){
  var scrolltop = document.documentElement.scrollTop || document.body.scrollTop;
  oTop.style.top = screenh - oTop.offsetHeight + scrolltop +"px";
 }
 oTop.onclick = function(){
  document.documentElement.scrollTop = document.body.scrollTop =0;
 }
} 
</script>




<!-- 打赏结束 -->
<!-- Baidu Button BEGIN -->

    
<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>


<!--
<div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>
-->

<!-- Baidu Button END -->      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>



 <nav id="pagination" >
    
    <a href="/2018/05/03/学习/找工作/Leetcode Java题解/" class="alignleft prev" >上一页</a>
    
    
    <a href="/2018/04/01/学习/找工作/Python开发复习资料/" class="alignright next" >下一页</a>
    
    <div class="clearfix"></div>
</nav>

<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ0NS82MDEz"></div>

<script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
</script>


</div></div>
    <aside id="sidebar" class="alignright">
  
<div>
<a href="javascript:;" class="popup-trigger">      
      <i class="menu-item-icon fa fa-search fa-fw"></i>        
   搜索
</a>
</div>


<div class="site-search">
<div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>
</div>

<script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
     
  var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        success: function( xmlResponse ) {
            // get the contents from search data
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var str='<ul class=\"search-result-list\">';
                var str1=str                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>';
                if (this.value.trim().length <= 0) {
                    return;
                }
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
					else { isMatch=false; } //更新此处
					
					//更新此处
					
                    // show search results
                    if (isMatch) {
                        str += "<li><a href='"+ data_url +"' class='search-result-title' target='_blank'>"+ "> " + data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out characters
                            var start = first_occur - 20;
                            var end = first_occur + 30;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 10;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substr(start, end); 
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<em class=\"search-keyword\">"+keyword+"</em>");
                            })
							//console.log(match_content)
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                    }
                })
                //修改
				if (str1==str){
					str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';
					}
				
				$resultContent.innerHTML = str;
            })
        }
    })
}
    // search function;
 </script>
<script>

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
	  proceedsearch();
	  //添加的
	  document.getElementById("local-search-result").innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>';
     
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>
  
<script type="text/javascript">      
     var search_path = "search.xml";
     if (search_path.length == 0) {
     	search_path = "search.xml";
     }
     var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
</script>





  
<div class="widget tag">
  <h3 class="title" id="categories">分类</h3>
     <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/ѧϰ/">ѧϰ</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ѧϰ/д��/">д��</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ѧϰ/д��/�K�/">�Ķ�</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a><span class="category-list-count">24</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/Math/">Math</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/Matlab/">Matlab</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/写作/">写作</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/写作/Doc/">Doc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/写作/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/写作/Markdown/">Markdown</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/机器学习/">机器学习</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/机器学习/TensorFlow/">TensorFlow</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/机器学习/推荐系统/">推荐系统</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/求职/">求职</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/学习/求职/基础知识/">基础知识</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/求职/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/求职/经历/">经历</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/求职/面试/">面试</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/Git/">Git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/IDEA/">IDEA</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/软件/">软件</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/软件/MacOS/">MacOS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/软件/Windows/">Windows</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">98</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Go/">Go</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Go/标准库/">标准库</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Java/">Java</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Java/Hibernate/">Hibernate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Java/Maven/">Maven</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Java/Mybatis/">Mybatis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Java/Spring/">Spring</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Java/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Java/标准库/">标准库</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Linux/">Linux</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Linux/Server/">Server</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Linux/日志监控/">日志监控</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/MacOS/">MacOS</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/MacOS/latex/">latex</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Python/">Python</a><span class="category-list-count">23</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Python/CGI编程/">CGI编程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Python/PyQt5/">PyQt5</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Python/数据库连接/">数据库连接</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Python/标准库/">标准库</a><span class="category-list-count">17</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Web/">Web</a><span class="category-list-count">27</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Web/Bootstrap/">Bootstrap</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Web/Django/">Django</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Web/Flask/">Flask</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Web/HTML/">HTML</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/Web/JavaScript/">JavaScript</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/并发编程/">并发编程</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/并发编程/Gevent/">Gevent</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据分析/">数据分析</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据分析/IPython/">IPython</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据分析/Matplotlib/">Matplotlib</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据分析/Numpy/">Numpy</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据分析/Pandas/">Pandas</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据分析/词云/">词云</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据库/">数据库</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据库/ElasticSearch/">ElasticSearch</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据库/MongoDB/">MongoDB</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据库/MySQL/">MySQL</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/数据库/Redis/">Redis</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/爬虫/">爬虫</a><span class="category-list-count">10</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/爬虫/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/爬虫/Scrapy/">Scrapy</a><span class="category-list-count">8</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/网络编程/">网络编程</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/网络编程/Socket/">Socket</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/折腾/">折腾</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/折腾/手机/">手机</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/折腾/路由器/">路由器</a><span class="category-list-count">1</span></li></ul></li></ul> 
</div>
 

  <div class="widget tag">
<h3 class="title">简介</h3>
<ul class="entry">
<li>博主：帅羊羊</li>
<li>现状：武大CS在读研究生</li>
<li>Theme: <a href="https://github.com/shuaiyy/lightum">Lightum</a>
<!-- <li>想交友的朋友请<a href="http://zipperary.com/about">联系我</a>！</li> -->
<li>QQ 号：2Ol896963</li>
<li>博客: 记录个人生活学习的点滴</li>
<!-- <font color="red">Hexo 交流群：287306637</font> -->
</ul>
</div>



  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=1&isWeibo=1&isFans=0&uid=2946363961&verifier=371067b2&dpc=1"></iframe>

  <div class="widget tag">
<h3 class="title">打赏</h3>
<ul class="entry">
<li>支付宝扫一扫，捐助支持，谢谢！</li>
<li><a href="http://img.shuaiyy.cn/blog/171004/LikDAfKDg0.png" title="" class="fancybox" rel="gallery3"><img width="100%" src="http://img.shuaiyy.cn/blog/171004/LikDAfKDg0.png"></a></li>
</ul>
</div>

  <!--  旧的标签

<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Android/">Android</a><small>1</small></li>
  
    <li><a href="/tags/Bootstrap/">Bootstrap</a><small>1</small></li>
  
    <li><a href="/tags/CentOS/">CentOS</a><small>1</small></li>
  
    <li><a href="/tags/Django/">Django</a><small>6</small></li>
  
    <li><a href="/tags/Docset/">Docset</a><small>1</small></li>
  
    <li><a href="/tags/ElasticSearch/">ElasticSearch</a><small>1</small></li>
  
    <li><a href="/tags/Enjoy/">Enjoy</a><small>0</small></li>
  
    <li><a href="/tags/Exam/">Exam</a><small>0</small></li>
  
    <li><a href="/tags/Flask/">Flask</a><small>19</small></li>
  
    <li><a href="/tags/Gevent/">Gevent</a><small>3</small></li>
  
    <li><a href="/tags/Git/">Git</a><small>4</small></li>
  
    <li><a href="/tags/Gitbook/">Gitbook</a><small>1</small></li>
  
    <li><a href="/tags/Go/">Go</a><small>1</small></li>
  
    <li><a href="/tags/HTML/">HTML</a><small>1</small></li>
  
    <li><a href="/tags/Hexo/">Hexo</a><small>1</small></li>
  
    <li><a href="/tags/Hibernate/">Hibernate</a><small>1</small></li>
  
    <li><a href="/tags/Html/">Html</a><small>2</small></li>
  
    <li><a href="/tags/IDEA/">IDEA</a><small>3</small></li>
  
    <li><a href="/tags/IPython/">IPython</a><small>1</small></li>
  
    <li><a href="/tags/Ipython/">Ipython</a><small>0</small></li>
  
    <li><a href="/tags/JQuery/">JQuery</a><small>1</small></li>
  
    <li><a href="/tags/Java/">Java</a><small>11</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>3</small></li>
  
    <li><a href="/tags/LaTeX/">LaTeX</a><small>3</small></li>
  
    <li><a href="/tags/LeetCode/">LeetCode</a><small>2</small></li>
  
    <li><a href="/tags/Linux/">Linux</a><small>11</small></li>
  
    <li><a href="/tags/Mac/">Mac</a><small>2</small></li>
  
    <li><a href="/tags/MachineLearning/">MachineLearning</a><small>1</small></li>
  
    <li><a href="/tags/Markdown/">Markdown</a><small>1</small></li>
  
    <li><a href="/tags/Math/">Math</a><small>6</small></li>
  
    <li><a href="/tags/Matlab/">Matlab</a><small>1</small></li>
  
    <li><a href="/tags/Matplotlib/">Matplotlib</a><small>1</small></li>
  
    <li><a href="/tags/Maven/">Maven</a><small>1</small></li>
  
    <li><a href="/tags/MongoDB/">MongoDB</a><small>1</small></li>
  
    <li><a href="/tags/Mongodb/">Mongodb</a><small>0</small></li>
  
    <li><a href="/tags/MyBatis/">MyBatis</a><small>1</small></li>
  
    <li><a href="/tags/MySQL/">MySQL</a><small>1</small></li>
  
    <li><a href="/tags/Notebook/">Notebook</a><small>1</small></li>
  
    <li><a href="/tags/Numpy/">Numpy</a><small>2</small></li>
  
    <li><a href="/tags/ORM/">ORM</a><small>2</small></li>
  
    <li><a href="/tags/Openwrt/">Openwrt</a><small>1</small></li>
  
    <li><a href="/tags/Optimization/">Optimization</a><small>8</small></li>
  
    <li><a href="/tags/Pandas/">Pandas</a><small>1</small></li>
  
    <li><a href="/tags/Phantomjs/">Phantomjs</a><small>1</small></li>
  
    <li><a href="/tags/Pip/">Pip</a><small>1</small></li>
  
    <li><a href="/tags/PyQt5/">PyQt5</a><small>4</small></li>
  
    <li><a href="/tags/Pycharm/">Pycharm</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>32</small></li>
  
    <li><a href="/tags/RESTful/">RESTful</a><small>1</small></li>
  
    <li><a href="/tags/Redis/">Redis</a><small>3</small></li>
  
    <li><a href="/tags/Scrapy/">Scrapy</a><small>8</small></li>
  
    <li><a href="/tags/Selenium/">Selenium</a><small>1</small></li>
  
    <li><a href="/tags/Service/">Service</a><small>1</small></li>
  
    <li><a href="/tags/Socket/">Socket</a><small>2</small></li>
  
    <li><a href="/tags/Spring/">Spring</a><small>1</small></li>
  
    <li><a href="/tags/SpringBoot/">SpringBoot</a><small>1</small></li>
  
    <li><a href="/tags/Tensorflow/">Tensorflow</a><small>1</small></li>
  
    <li><a href="/tags/Web/">Web</a><small>19</small></li>
  
    <li><a href="/tags/WordCloud/">WordCloud</a><small>1</small></li>
  
    <li><a href="/tags/Zabbix/">Zabbix</a><small>1</small></li>
  
    <li><a href="/tags/Zeal/">Zeal</a><small>1</small></li>
  
    <li><a href="/tags/flask/">flask</a><small>0</small></li>
  
    <li><a href="/tags/gevent/">gevent</a><small>0</small></li>
  
    <li><a href="/tags/git/">git</a><small>0</small></li>
  
    <li><a href="/tags/gitbook/">gitbook</a><small>0</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>0</small></li>
  
    <li><a href="/tags/python/">python</a><small>0</small></li>
  
    <li><a href="/tags/restful/">restful</a><small>0</small></li>
  
    <li><a href="/tags/socket/">socket</a><small>0</small></li>
  
    <li><a href="/tags/tensorflow/">tensorflow</a><small>0</small></li>
  
    <li><a href="/tags/刷题/">刷题</a><small>2</small></li>
  
    <li><a href="/tags/推荐系统/">推荐系统</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>2</small></li>
  
    <li><a href="/tags/机器学习/">机器学习</a><small>3</small></li>
  
    <li><a href="/tags/框架/">框架</a><small>1</small></li>
  
    <li><a href="/tags/求职/">求职</a><small>6</small></li>
  
    <li><a href="/tags/测试/">测试</a><small>1</small></li>
  
    <li><a href="/tags/爬虫/">爬虫</a><small>9</small></li>
  
    <li><a href="/tags/经历/">经历</a><small>1</small></li>
  
    <li><a href="/tags/词云/">词云</a><small>1</small></li>
  
    <li><a href="/tags/面试/">面试</a><small>1</small></li>
  
  </ul>
</div>

-->

<!-- 使用hexo-tag-cloud 生成的-->

<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/PyQt5/" style="font-size: 16.33px; color: #b0a">PyQt5</a> <a href="/tags/Hexo/" style="font-size: 13px; color: #90f">Hexo</a> <a href="/tags/Math/" style="font-size: 17.44px; color: #c6008e">Math</a> <a href="/tags/Optimization/" style="font-size: 18.56px; color: #d20071">Optimization</a> <a href="/tags/Matlab/" style="font-size: 13px; color: #90f">Matlab</a> <a href="/tags/MachineLearning/" style="font-size: 13px; color: #90f">MachineLearning</a> <a href="/tags/Bootstrap/" style="font-size: 13px; color: #90f">Bootstrap</a> <a href="/tags/Linux/" style="font-size: 20.78px; color: #e80039">Linux</a> <a href="/tags/CentOS/" style="font-size: 13px; color: #90f">CentOS</a> <a href="/tags/Django/" style="font-size: 17.44px; color: #c6008e">Django</a> <a href="/tags/Flask/" style="font-size: 21.89px; color: #f4001c">Flask</a> <a href="/tags/Web/" style="font-size: 21.89px; color: #f4001c">Web</a> <a href="/tags/测试/" style="font-size: 13px; color: #90f">测试</a> <a href="/tags/Git/" style="font-size: 16.33px; color: #b0a">Git</a> <a href="/tags/HTML/" style="font-size: 13px; color: #90f">HTML</a> <a href="/tags/Java/" style="font-size: 20.78px; color: #e80039">Java</a> <a href="/tags/IDEA/" style="font-size: 15.22px; color: #b000c6">IDEA</a> <a href="/tags/ORM/" style="font-size: 14.11px; color: #a400e3">ORM</a> <a href="/tags/Hibernate/" style="font-size: 13px; color: #90f">Hibernate</a> <a href="/tags/Html/" style="font-size: 14.11px; color: #a400e3">Html</a> <a href="/tags/JavaScript/" style="font-size: 15.22px; color: #b000c6">JavaScript</a> <a href="/tags/Python/" style="font-size: 23px; color: #f00">Python</a> <a href="/tags/Notebook/" style="font-size: 13px; color: #90f">Notebook</a> <a href="/tags/Service/" style="font-size: 13px; color: #90f">Service</a> <a href="/tags/LaTeX/" style="font-size: 15.22px; color: #b000c6">LaTeX</a> <a href="/tags/Mac/" style="font-size: 14.11px; color: #a400e3">Mac</a> <a href="/tags/Markdown/" style="font-size: 13px; color: #90f">Markdown</a> <a href="/tags/Matplotlib/" style="font-size: 13px; color: #90f">Matplotlib</a> <a href="/tags/Maven/" style="font-size: 13px; color: #90f">Maven</a> <a href="/tags/MySQL/" style="font-size: 13px; color: #90f">MySQL</a> <a href="/tags/数据库/" style="font-size: 14.11px; color: #a400e3">数据库</a> <a href="/tags/MyBatis/" style="font-size: 13px; color: #90f">MyBatis</a> <a href="/tags/Numpy/" style="font-size: 14.11px; color: #a400e3">Numpy</a> <a href="/tags/Pandas/" style="font-size: 13px; color: #90f">Pandas</a> <a href="/tags/Android/" style="font-size: 13px; color: #90f">Android</a> <a href="/tags/框架/" style="font-size: 13px; color: #90f">框架</a> <a href="/tags/爬虫/" style="font-size: 19.67px; color: #d05">爬虫</a> <a href="/tags/Selenium/" style="font-size: 13px; color: #90f">Selenium</a> <a href="/tags/Phantomjs/" style="font-size: 13px; color: #90f">Phantomjs</a> <a href="/tags/WordCloud/" style="font-size: 13px; color: #90f">WordCloud</a> <a href="/tags/词云/" style="font-size: 13px; color: #90f">词云</a> <a href="/tags/Pip/" style="font-size: 13px; color: #90f">Pip</a> <a href="/tags/Redis/" style="font-size: 15.22px; color: #b000c6">Redis</a> <a href="/tags/Scrapy/" style="font-size: 18.56px; color: #d20071">Scrapy</a> <a href="/tags/SpringBoot/" style="font-size: 13px; color: #90f">SpringBoot</a> <a href="/tags/机器学习/" style="font-size: 15.22px; color: #b000c6">机器学习</a> <a href="/tags/Spring/" style="font-size: 13px; color: #90f">Spring</a> <a href="/tags/Zabbix/" style="font-size: 13px; color: #90f">Zabbix</a> <a href="/tags/Zeal/" style="font-size: 13px; color: #90f">Zeal</a> <a href="/tags/Gevent/" style="font-size: 15.22px; color: #b000c6">Gevent</a> <a href="/tags/IPython/" style="font-size: 13px; color: #90f">IPython</a> <a href="/tags/MongoDB/" style="font-size: 13px; color: #90f">MongoDB</a> <a href="/tags/Socket/" style="font-size: 14.11px; color: #a400e3">Socket</a> <a href="/tags/RESTful/" style="font-size: 13px; color: #90f">RESTful</a> <a href="/tags/Gitbook/" style="font-size: 13px; color: #90f">Gitbook</a> <a href="/tags/Docset/" style="font-size: 13px; color: #90f">Docset</a> <a href="/tags/Tensorflow/" style="font-size: 13px; color: #90f">Tensorflow</a> <a href="/tags/Pycharm/" style="font-size: 13px; color: #90f">Pycharm</a> <a href="/tags/JQuery/" style="font-size: 13px; color: #90f">JQuery</a> <a href="/tags/求职/" style="font-size: 17.44px; color: #c6008e">求职</a> <a href="/tags/Openwrt/" style="font-size: 13px; color: #90f">Openwrt</a> <a href="/tags/推荐系统/" style="font-size: 13px; color: #90f">推荐系统</a> <a href="/tags/ElasticSearch/" style="font-size: 13px; color: #90f">ElasticSearch</a> <a href="/tags/刷题/" style="font-size: 14.11px; color: #a400e3">刷题</a> <a href="/tags/LeetCode/" style="font-size: 14.11px; color: #a400e3">LeetCode</a>
  </div>
</div>


  <div class="widget tag">
  <h3 class="title">日历云</h3>
  <div id="calendar"></div>
</div>

  
  <div class="widget tag">
    <h3 class="title">归档</h3>
	<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">2018年11月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">2018年10月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">2018年09月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">2018年06月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">2018年05月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">2018年04月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">2018年03月</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">2018年02月</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">2018年01月</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">2017年12月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">2017年11月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">2017年10月</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">2017年09月</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">2017年08月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">2017年05月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">2017年03月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">2017年02月</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">2016年12月</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">2016年11月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">2016年10月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">2016年09月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">2016年08月</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">2016年07月</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">2016年05月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">2015年09月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">2015年03月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">2015年02月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">2015年01月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">2014年12月</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">2014年11月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">2014年09月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">2014年08月</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">2014年07月</a><span class="archive-list-count">2</span></li></ul>
  </div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner">
<section>
<div class="copyright">
		
		  
		  &copy;2014&mdash; <span itemprop="copyrightYear">2018</span>
		  
  <span class="with-love">
    <i class="fa fa-heart" style="color:red"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuaiyy</span>
</div>
主题 - <a href="https://github.com/shuaiyy/lightum">Lightum</a>, Improved from <a href="https://github.com/hexojs/hexo-theme-light">Light</a>, by <a href="/">shuaiyy</a> 
<p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p>
</section>
<div class="clearfix"></div>
</footer>
  <script src="//libs.baidu.com/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<!-- add calendar widget -->

  <script src="/js/calendar.js"></script>
  <script src="/js/languages.js"></script>
  <script type="text/javascript">
    $(function() {
    
      $('#calendar').aCalendar('zh-CN',{single:true, root:'calendar/'});
    
    });
  </script>



<!-- 返回顶部 -->
<div id="toTop">
	<a href="#">▲</a>
	<a href="#footer">▼</a>
</div>
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</body>
</html>


<a href="https://github.com/shuaiyy" target="_blank"><img style="position: absolute; top: 0; left: 0; border: 0;" src="/imgs/forkme_left_green_007200.png" alt="Fork me on GitHub"></a>
